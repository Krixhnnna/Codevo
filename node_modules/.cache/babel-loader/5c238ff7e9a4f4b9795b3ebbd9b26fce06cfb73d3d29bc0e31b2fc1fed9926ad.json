{"ast":null,"code":"// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\nfunction isPowerOf2(value) {\n  return (value & value - 1) === 0;\n}\nlet ID = 1;\nexport class Texture {\n  constructor(gl) {\n    let {\n      image,\n      target = gl.TEXTURE_2D,\n      type = gl.UNSIGNED_BYTE,\n      format = gl.RGBA,\n      internalFormat = format,\n      wrapS = gl.CLAMP_TO_EDGE,\n      wrapT = gl.CLAMP_TO_EDGE,\n      generateMipmaps = true,\n      minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n      magFilter = gl.LINEAR,\n      premultiplyAlpha = false,\n      unpackAlignment = 4,\n      flipY = target == gl.TEXTURE_2D ? true : false,\n      anisotropy = 0,\n      level = 0,\n      width,\n      // used for RenderTargets or Data Textures\n      height = width\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.id = ID++;\n    this.image = image;\n    this.target = target;\n    this.type = type;\n    this.format = format;\n    this.internalFormat = internalFormat;\n    this.minFilter = minFilter;\n    this.magFilter = magFilter;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.generateMipmaps = generateMipmaps;\n    this.premultiplyAlpha = premultiplyAlpha;\n    this.unpackAlignment = unpackAlignment;\n    this.flipY = flipY;\n    this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n    this.level = level;\n    this.width = width;\n    this.height = height;\n    this.texture = this.gl.createTexture();\n    this.store = {\n      image: null\n    };\n\n    // Alias for state store to avoid redundant calls for global state\n    this.glState = this.gl.renderer.state;\n\n    // State store to avoid redundant calls for per-texture state\n    this.state = {};\n    this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n    this.state.magFilter = this.gl.LINEAR;\n    this.state.wrapS = this.gl.REPEAT;\n    this.state.wrapT = this.gl.REPEAT;\n    this.state.anisotropy = 0;\n  }\n  bind() {\n    // Already bound to active texture unit\n    if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n    this.gl.bindTexture(this.target, this.texture);\n    this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n  }\n  update() {\n    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n    // Make sure that texture is bound to its texture unit\n    if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n      // set active texture unit to perform texture functions\n      this.gl.renderer.activeTexture(textureUnit);\n      this.bind();\n    }\n    if (!needsUpdate) return;\n    this.needsUpdate = false;\n    if (this.flipY !== this.glState.flipY) {\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n      this.glState.flipY = this.flipY;\n    }\n    if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n      this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n      this.glState.premultiplyAlpha = this.premultiplyAlpha;\n    }\n    if (this.unpackAlignment !== this.glState.unpackAlignment) {\n      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n      this.glState.unpackAlignment = this.unpackAlignment;\n    }\n    if (this.minFilter !== this.state.minFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n      this.state.minFilter = this.minFilter;\n    }\n    if (this.magFilter !== this.state.magFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n      this.state.magFilter = this.magFilter;\n    }\n    if (this.wrapS !== this.state.wrapS) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n      this.state.wrapS = this.wrapS;\n    }\n    if (this.wrapT !== this.state.wrapT) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n      this.state.wrapT = this.wrapT;\n    }\n    if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n      this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n      this.state.anisotropy = this.anisotropy;\n    }\n    if (this.image) {\n      if (this.image.width) {\n        this.width = this.image.width;\n        this.height = this.image.height;\n      }\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // For cube maps\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n        }\n      } else if (ArrayBuffer.isView(this.image)) {\n        // Data texture\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n      } else if (this.image.isCompressedTexture) {\n        // Compressed texture\n        for (let level = 0; level < this.image.length; level++) {\n          this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n        }\n      } else {\n        // Regular texture\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n      }\n      if (this.generateMipmaps) {\n        // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n        if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n          this.generateMipmaps = false;\n          this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n          this.minFilter = this.gl.LINEAR;\n        } else {\n          this.gl.generateMipmap(this.target);\n        }\n      }\n\n      // Callback for when data is pushed to GPU\n      this.onUpdate && this.onUpdate();\n    } else {\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // Upload empty pixel for each side while no image to avoid errors while image or video loading\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n        }\n      } else if (this.width) {\n        // image intentionally left null for RenderTarget\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n      } else {\n        // Upload empty pixel if no image to avoid errors while image or video loading\n        this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n      }\n    }\n    this.store.image = this.image;\n  }\n}","map":{"version":3,"names":["emptyPixel","Uint8Array","isPowerOf2","value","ID","Texture","constructor","gl","image","target","TEXTURE_2D","type","UNSIGNED_BYTE","format","RGBA","internalFormat","wrapS","CLAMP_TO_EDGE","wrapT","generateMipmaps","minFilter","NEAREST_MIPMAP_LINEAR","LINEAR","magFilter","premultiplyAlpha","unpackAlignment","flipY","anisotropy","level","width","height","arguments","length","undefined","id","Math","min","renderer","parameters","maxAnisotropy","texture","createTexture","store","glState","state","REPEAT","bind","textureUnits","activeTextureUnit","bindTexture","update","textureUnit","needsUpdate","activeTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","texParameterf","getExtension","TEXTURE_MAX_ANISOTROPY_EXT","TEXTURE_CUBE_MAP","i","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","ArrayBuffer","isView","isCompressedTexture","compressedTexImage2D","data","isWebgl2","generateMipmap","onUpdate"],"sources":["/Users/krishnapandey/Desktop/Codevo/node_modules/ogl/src/core/Texture.js"],"sourcesContent":["// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n}\n\nlet ID = 1;\n\nexport class Texture {\n    constructor(\n        gl,\n        {\n            image,\n            target = gl.TEXTURE_2D,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            generateMipmaps = true,\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = target == gl.TEXTURE_2D ? true : false,\n            anisotropy = 0,\n            level = 0,\n            width, // used for RenderTargets or Data Textures\n            height = width,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.id = ID++;\n\n        this.image = image;\n        this.target = target;\n        this.type = type;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.minFilter = minFilter;\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.generateMipmaps = generateMipmaps;\n        this.premultiplyAlpha = premultiplyAlpha;\n        this.unpackAlignment = unpackAlignment;\n        this.flipY = flipY;\n        this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.texture = this.gl.createTexture();\n\n        this.store = {\n            image: null,\n        };\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // State store to avoid redundant calls for per-texture state\n        this.state = {};\n        this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        this.state.magFilter = this.gl.LINEAR;\n        this.state.wrapS = this.gl.REPEAT;\n        this.state.wrapT = this.gl.REPEAT;\n        this.state.anisotropy = 0;\n    }\n\n    bind() {\n        // Already bound to active texture unit\n        if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n        this.gl.bindTexture(this.target, this.texture);\n        this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n    }\n\n    update(textureUnit = 0) {\n        const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n        // Make sure that texture is bound to its texture unit\n        if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n            // set active texture unit to perform texture functions\n            this.gl.renderer.activeTexture(textureUnit);\n            this.bind();\n        }\n\n        if (!needsUpdate) return;\n        this.needsUpdate = false;\n\n        if (this.flipY !== this.glState.flipY) {\n            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n            this.glState.flipY = this.flipY;\n        }\n\n        if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n            this.glState.premultiplyAlpha = this.premultiplyAlpha;\n        }\n\n        if (this.unpackAlignment !== this.glState.unpackAlignment) {\n            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n            this.glState.unpackAlignment = this.unpackAlignment;\n        }\n\n        if (this.minFilter !== this.state.minFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n            this.state.minFilter = this.minFilter;\n        }\n\n        if (this.magFilter !== this.state.magFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n            this.state.magFilter = this.magFilter;\n        }\n\n        if (this.wrapS !== this.state.wrapS) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n            this.state.wrapS = this.wrapS;\n        }\n\n        if (this.wrapT !== this.state.wrapT) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n            this.state.wrapT = this.wrapT;\n        }\n\n        if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n            this.gl.texParameterf(\n                this.target,\n                this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT,\n                this.anisotropy\n            );\n            this.state.anisotropy = this.anisotropy;\n        }\n\n        if (this.image) {\n            if (this.image.width) {\n                this.width = this.image.width;\n                this.height = this.image.height;\n            }\n\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // For cube maps\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(\n                        this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\n                        this.level,\n                        this.internalFormat,\n                        this.format,\n                        this.type,\n                        this.image[i]\n                    );\n                }\n            } else if (ArrayBuffer.isView(this.image)) {\n                // Data texture\n                this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n            } else if (this.image.isCompressedTexture) {\n                // Compressed texture\n                for (let level = 0; level < this.image.length; level++) {\n                    this.gl.compressedTexImage2D(\n                        this.target,\n                        level,\n                        this.internalFormat,\n                        this.image[level].width,\n                        this.image[level].height,\n                        0,\n                        this.image[level].data\n                    );\n                }\n            } else {\n                // Regular texture\n                this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n            }\n\n            if (this.generateMipmaps) {\n                // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n                if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n                    this.generateMipmaps = false;\n                    this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n                    this.minFilter = this.gl.LINEAR;\n                } else {\n                    this.gl.generateMipmap(this.target);\n                }\n            }\n\n            // Callback for when data is pushed to GPU\n            this.onUpdate && this.onUpdate();\n        } else {\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // Upload empty pixel for each side while no image to avoid errors while image or video loading\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(\n                        this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\n                        0,\n                        this.gl.RGBA,\n                        1,\n                        1,\n                        0,\n                        this.gl.RGBA,\n                        this.gl.UNSIGNED_BYTE,\n                        emptyPixel\n                    );\n                }\n            } else if (this.width) {\n                // image intentionally left null for RenderTarget\n                this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n            } else {\n                // Upload empty pixel if no image to avoid errors while image or video loading\n                this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n            }\n        }\n        this.store.image = this.image;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}