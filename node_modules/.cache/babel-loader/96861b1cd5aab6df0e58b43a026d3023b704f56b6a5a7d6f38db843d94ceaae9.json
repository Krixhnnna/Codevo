{"ast":null,"code":"import { Mesh } from '../core/Mesh.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\nconst tempMat4 = new Mat4();\nconst identity = new Mat4();\nexport class GLTFSkin extends Mesh {\n  constructor(gl) {\n    let {\n      skeleton,\n      geometry,\n      program,\n      mode = gl.TRIANGLES\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, {\n      geometry,\n      program,\n      mode\n    });\n    this.skeleton = skeleton;\n    this.program = program;\n    this.createBoneTexture();\n    this.animations = [];\n  }\n  createBoneTexture() {\n    if (!this.skeleton.joints.length) return;\n    const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.skeleton.joints.length * 4)) / Math.LN2)));\n    this.boneMatrices = new Float32Array(size * size * 4);\n    this.boneTextureSize = size;\n    this.boneTexture = new Texture(this.gl, {\n      image: this.boneMatrices,\n      generateMipmaps: false,\n      type: this.gl.FLOAT,\n      internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n      minFilter: this.gl.NEAREST,\n      magFilter: this.gl.NEAREST,\n      flipY: false,\n      width: size\n    });\n  }\n\n  // addAnimation(data) {\n  //     const animation = new Animation({ objects: this.bones, data });\n  //     this.animations.push(animation);\n  //     return animation;\n  // }\n\n  // updateAnimations() {\n  //     // Calculate combined animation weight\n  //     let total = 0;\n  //     this.animations.forEach((animation) => (total += animation.weight));\n\n  //     this.animations.forEach((animation, i) => {\n  //         // force first animation to set in order to reset frame\n  //         animation.update(total, i === 0);\n  //     });\n  // }\n\n  updateUniforms() {\n    // Update bone texture\n    this.skeleton.joints.forEach((bone, i) => {\n      // Find difference between current and bind pose\n      tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n      this.boneMatrices.set(tempMat4, i * 16);\n    });\n    if (this.boneTexture) this.boneTexture.needsUpdate = true;\n  }\n  draw() {\n    let {\n      camera\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.program.uniforms.boneTexture) {\n      Object.assign(this.program.uniforms, {\n        boneTexture: {\n          value: this.boneTexture\n        },\n        boneTextureSize: {\n          value: this.boneTextureSize\n        }\n      });\n    }\n    this.updateUniforms();\n\n    // Switch the world matrix with identity to ignore any transforms\n    // on the mesh itself - only use skeleton's transforms\n    const _worldMatrix = this.worldMatrix;\n    this.worldMatrix = identity;\n    super.draw({\n      camera\n    });\n\n    // Switch back to leave identity untouched\n    this.worldMatrix = _worldMatrix;\n  }\n}","map":{"version":3,"names":["Mesh","Mat4","Texture","tempMat4","identity","GLTFSkin","constructor","gl","skeleton","geometry","program","mode","TRIANGLES","arguments","length","undefined","createBoneTexture","animations","joints","size","Math","max","pow","ceil","log","sqrt","LN2","boneMatrices","Float32Array","boneTextureSize","boneTexture","image","generateMipmaps","type","FLOAT","internalFormat","renderer","isWebgl2","RGBA32F","RGBA","minFilter","NEAREST","magFilter","flipY","width","updateUniforms","forEach","bone","i","multiply","worldMatrix","bindInverse","set","needsUpdate","draw","camera","uniforms","Object","assign","value","_worldMatrix"],"sources":["/Users/krishnapandey/Desktop/Codevo/node_modules/ogl/src/extras/GLTFSkin.js"],"sourcesContent":["import { Mesh } from '../core/Mesh.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\n\nconst tempMat4 = new Mat4();\nconst identity = new Mat4();\n\nexport class GLTFSkin extends Mesh {\n    constructor(gl, { skeleton, geometry, program, mode = gl.TRIANGLES } = {}) {\n        super(gl, { geometry, program, mode });\n        this.skeleton = skeleton;\n        this.program = program;\n        this.createBoneTexture();\n        this.animations = [];\n    }\n\n    createBoneTexture() {\n        if (!this.skeleton.joints.length) return;\n        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.skeleton.joints.length * 4)) / Math.LN2)));\n        this.boneMatrices = new Float32Array(size * size * 4);\n        this.boneTextureSize = size;\n        this.boneTexture = new Texture(this.gl, {\n            image: this.boneMatrices,\n            generateMipmaps: false,\n            type: this.gl.FLOAT,\n            internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n            minFilter: this.gl.NEAREST,\n            magFilter: this.gl.NEAREST,\n            flipY: false,\n            width: size,\n        });\n    }\n\n    // addAnimation(data) {\n    //     const animation = new Animation({ objects: this.bones, data });\n    //     this.animations.push(animation);\n    //     return animation;\n    // }\n\n    // updateAnimations() {\n    //     // Calculate combined animation weight\n    //     let total = 0;\n    //     this.animations.forEach((animation) => (total += animation.weight));\n\n    //     this.animations.forEach((animation, i) => {\n    //         // force first animation to set in order to reset frame\n    //         animation.update(total, i === 0);\n    //     });\n    // }\n\n    updateUniforms() {\n        // Update bone texture\n        this.skeleton.joints.forEach((bone, i) => {\n            // Find difference between current and bind pose\n            tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n            this.boneMatrices.set(tempMat4, i * 16);\n        });\n        if (this.boneTexture) this.boneTexture.needsUpdate = true;\n    }\n\n    draw({ camera } = {}) {\n        if (!this.program.uniforms.boneTexture) {\n            Object.assign(this.program.uniforms, {\n                boneTexture: { value: this.boneTexture },\n                boneTextureSize: { value: this.boneTextureSize },\n            });\n        }\n\n        this.updateUniforms();\n\n        // Switch the world matrix with identity to ignore any transforms\n        // on the mesh itself - only use skeleton's transforms\n        const _worldMatrix = this.worldMatrix;\n        this.worldMatrix = identity;\n\n        super.draw({ camera });\n\n        // Switch back to leave identity untouched\n        this.worldMatrix = _worldMatrix;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}