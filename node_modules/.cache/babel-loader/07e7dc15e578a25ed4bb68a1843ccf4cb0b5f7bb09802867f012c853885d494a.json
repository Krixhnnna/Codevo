{"ast":null,"code":"// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n\nimport { Vec3 } from '../math/Vec3.js';\nconst tempVec3 = new Vec3();\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\nexport class Geometry {\n  constructor(gl) {\n    let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n    this.gl = gl;\n    this.attributes = attributes;\n    this.id = ID++;\n\n    // Store one VAO per program attribute locations order\n    this.VAOs = {};\n    this.drawRange = {\n      start: 0,\n      count: 0\n    };\n    this.instancedCount = 0;\n\n    // Unbind current VAO so that new buffers don't get added to active mesh\n    this.gl.renderer.bindVertexArray(null);\n    this.gl.renderer.currentGeometry = null;\n\n    // Alias for state store to avoid redundant calls for global state\n    this.glState = this.gl.renderer.state;\n\n    // create the buffers\n    for (let key in attributes) {\n      this.addAttribute(key, attributes[key]);\n    }\n  }\n  addAttribute(key, attr) {\n    this.attributes[key] = attr;\n\n    // Set options\n    attr.id = ATTR_ID++; // TODO: currently unused, remove?\n    attr.size = attr.size || 1;\n    attr.type = attr.type || (attr.data.constructor === Float32Array ? this.gl.FLOAT : attr.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT); // Uint32Array\n    attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n    attr.normalized = attr.normalized || false;\n    attr.stride = attr.stride || 0;\n    attr.offset = attr.offset || 0;\n    attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n    attr.divisor = attr.instanced || 0;\n    attr.needsUpdate = false;\n    if (!attr.buffer) {\n      attr.buffer = this.gl.createBuffer();\n\n      // Push data to buffer\n      this.updateAttribute(attr);\n    }\n\n    // Update geometry counts. If indexed, ignore regular attributes\n    if (attr.divisor) {\n      this.isInstanced = true;\n      if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n        console.warn('geometry has multiple instanced buffers of different length');\n        return this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor);\n      }\n      this.instancedCount = attr.count * attr.divisor;\n    } else if (key === 'index') {\n      this.drawRange.count = attr.count;\n    } else if (!this.attributes.index) {\n      this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n    }\n  }\n  updateAttribute(attr) {\n    if (this.glState.boundBuffer !== attr.buffer) {\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n    }\n    this.gl.bufferData(attr.target, attr.data, this.gl.STATIC_DRAW);\n    attr.needsUpdate = false;\n  }\n  setIndex(value) {\n    this.addAttribute('index', value);\n  }\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n  setInstancedCount(value) {\n    this.instancedCount = value;\n  }\n  createVAO(program) {\n    this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n    this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n    this.bindAttributes(program);\n  }\n  bindAttributes(program) {\n    // Link all attributes to program using gl.vertexAttribPointer\n    program.attributeLocations.forEach((location, _ref) => {\n      let {\n        name,\n        type\n      } = _ref;\n      // If geometry missing a required shader attribute\n      if (!this.attributes[name]) {\n        console.warn(\"active attribute \".concat(name, \" not being supplied\"));\n        return;\n      }\n      const attr = this.attributes[name];\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n\n      // For matrix attributes, buffer needs to be defined per column\n      let numLoc = 1;\n      if (type === 35674) numLoc = 2; // mat2\n      if (type === 35675) numLoc = 3; // mat3\n      if (type === 35676) numLoc = 4; // mat4\n\n      const size = attr.size / numLoc;\n      const stride = numLoc === 1 ? 0 : numLoc * numLoc * numLoc;\n      const offset = numLoc === 1 ? 0 : numLoc * numLoc;\n      for (let i = 0; i < numLoc; i++) {\n        this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n        this.gl.enableVertexAttribArray(location + i);\n\n        // For instanced attributes, divisor needs to be set.\n        // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n        this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n      }\n    });\n\n    // Bind indices if geometry indexed\n    if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n  }\n  draw(_ref2) {\n    let {\n      program,\n      mode = this.gl.TRIANGLES\n    } = _ref2;\n    if (this.gl.renderer.currentGeometry !== \"\".concat(this.id, \"_\").concat(program.attributeOrder)) {\n      if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n      this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n      this.gl.renderer.currentGeometry = \"\".concat(this.id, \"_\").concat(program.attributeOrder);\n    }\n\n    // Check if any attributes need updating\n    program.attributeLocations.forEach((location, _ref3) => {\n      let {\n        name\n      } = _ref3;\n      const attr = this.attributes[name];\n      if (attr.needsUpdate) this.updateAttribute(attr);\n    });\n    if (this.isInstanced) {\n      if (this.attributes.index) {\n        this.gl.renderer.drawElementsInstanced(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * 2, this.instancedCount);\n      } else {\n        this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n      }\n    } else {\n      if (this.attributes.index) {\n        this.gl.drawElements(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * 2);\n      } else {\n        this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n      }\n    }\n  }\n  getPosition() {\n    // Use position buffer, or min/max if available\n    const attr = this.attributes.position;\n    // if (attr.min) return [...attr.min, ...attr.max];\n    if (attr.data) return attr;\n    if (isBoundsWarned) return;\n    console.warn('No position buffer data found to compute bounds');\n    return isBoundsWarned = true;\n  }\n  computeBoundingBox(attr) {\n    if (!attr) attr = this.getPosition();\n    const array = attr.data;\n    const stride = attr.stride || attr.size;\n    if (!this.bounds) {\n      this.bounds = {\n        min: new Vec3(),\n        max: new Vec3(),\n        center: new Vec3(),\n        scale: new Vec3(),\n        radius: Infinity\n      };\n    }\n    const min = this.bounds.min;\n    const max = this.bounds.max;\n    const center = this.bounds.center;\n    const scale = this.bounds.scale;\n    min.set(+Infinity);\n    max.set(-Infinity);\n\n    // TODO: check size of position (eg triangle with Vec2)\n    for (let i = 0, l = array.length; i < l; i += stride) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      min.x = Math.min(x, min.x);\n      min.y = Math.min(y, min.y);\n      min.z = Math.min(z, min.z);\n      max.x = Math.max(x, max.x);\n      max.y = Math.max(y, max.y);\n      max.z = Math.max(z, max.z);\n    }\n    scale.sub(max, min);\n    center.add(min, max).divide(2);\n  }\n  computeBoundingSphere(attr) {\n    if (!attr) attr = this.getPosition();\n    const array = attr.data;\n    const stride = attr.stride || attr.size;\n    if (!this.bounds) this.computeBoundingBox(attr);\n    let maxRadiusSq = 0;\n    for (let i = 0, l = array.length; i < l; i += stride) {\n      tempVec3.fromArray(array, i);\n      maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n    }\n    this.bounds.radius = Math.sqrt(maxRadiusSq);\n  }\n  remove() {\n    for (let key in this.VAOs) {\n      this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n      delete this.VAOs[key];\n    }\n    for (let key in this.attributes) {\n      this.gl.deleteBuffer(this.attributes[key].buffer);\n      delete this.attributes[key];\n    }\n  }\n}","map":{"version":3,"names":["Vec3","tempVec3","ID","ATTR_ID","isBoundsWarned","Geometry","constructor","gl","attributes","arguments","length","undefined","canvas","console","error","id","VAOs","drawRange","start","count","instancedCount","renderer","bindVertexArray","currentGeometry","glState","state","key","addAttribute","attr","size","type","data","Float32Array","FLOAT","Uint16Array","UNSIGNED_SHORT","UNSIGNED_INT","target","ELEMENT_ARRAY_BUFFER","ARRAY_BUFFER","normalized","stride","offset","byteLength","divisor","instanced","needsUpdate","buffer","createBuffer","updateAttribute","isInstanced","warn","Math","min","index","max","boundBuffer","bindBuffer","bufferData","STATIC_DRAW","setIndex","value","setDrawRange","setInstancedCount","createVAO","program","attributeOrder","createVertexArray","bindAttributes","attributeLocations","forEach","location","_ref","name","concat","numLoc","i","vertexAttribPointer","enableVertexAttribArray","vertexAttribDivisor","draw","_ref2","mode","TRIANGLES","_ref3","drawElementsInstanced","drawArraysInstanced","drawElements","drawArrays","getPosition","position","computeBoundingBox","array","bounds","center","scale","radius","Infinity","set","l","x","y","z","sub","add","divide","computeBoundingSphere","maxRadiusSq","fromArray","squaredDistance","sqrt","remove","deleteVertexArray","deleteBuffer"],"sources":["/Users/krishnapandey/Desktop/Codevo/node_modules/ogl/src/core/Geometry.js"],"sourcesContent":["// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempVec3 = new Vec3();\n\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\n\nexport class Geometry {\n    constructor(gl, attributes = {}) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n        this.gl = gl;\n        this.attributes = attributes;\n        this.id = ID++;\n\n        // Store one VAO per program attribute locations order\n        this.VAOs = {};\n\n        this.drawRange = { start: 0, count: 0 };\n        this.instancedCount = 0;\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        this.gl.renderer.bindVertexArray(null);\n        this.gl.renderer.currentGeometry = null;\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // create the buffers\n        for (let key in attributes) {\n            this.addAttribute(key, attributes[key]);\n        }\n    }\n\n    addAttribute(key, attr) {\n        this.attributes[key] = attr;\n\n        // Set options\n        attr.id = ATTR_ID++; // TODO: currently unused, remove?\n        attr.size = attr.size || 1;\n        attr.type =\n            attr.type ||\n            (attr.data.constructor === Float32Array\n                ? this.gl.FLOAT\n                : attr.data.constructor === Uint16Array\n                ? this.gl.UNSIGNED_SHORT\n                : this.gl.UNSIGNED_INT); // Uint32Array\n        attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n        attr.normalized = attr.normalized || false;\n        attr.stride = attr.stride || 0;\n        attr.offset = attr.offset || 0;\n        attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n        attr.divisor = attr.instanced || 0;\n        attr.needsUpdate = false;\n\n        if (!attr.buffer) {\n            attr.buffer = this.gl.createBuffer();\n\n            // Push data to buffer\n            this.updateAttribute(attr);\n        }\n\n        // Update geometry counts. If indexed, ignore regular attributes\n        if (attr.divisor) {\n            this.isInstanced = true;\n            if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n                console.warn('geometry has multiple instanced buffers of different length');\n                return (this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor));\n            }\n            this.instancedCount = attr.count * attr.divisor;\n        } else if (key === 'index') {\n            this.drawRange.count = attr.count;\n        } else if (!this.attributes.index) {\n            this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n        }\n    }\n\n    updateAttribute(attr) {\n        if (this.glState.boundBuffer !== attr.buffer) {\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n        }\n        this.gl.bufferData(attr.target, attr.data, this.gl.STATIC_DRAW);\n        attr.needsUpdate = false;\n    }\n\n    setIndex(value) {\n        this.addAttribute('index', value);\n    }\n\n    setDrawRange(start, count) {\n        this.drawRange.start = start;\n        this.drawRange.count = count;\n    }\n\n    setInstancedCount(value) {\n        this.instancedCount = value;\n    }\n\n    createVAO(program) {\n        this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n        this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n        this.bindAttributes(program);\n    }\n\n    bindAttributes(program) {\n        // Link all attributes to program using gl.vertexAttribPointer\n        program.attributeLocations.forEach((location, { name, type }) => {\n            // If geometry missing a required shader attribute\n            if (!this.attributes[name]) {\n                console.warn(`active attribute ${name} not being supplied`);\n                return;\n            }\n\n            const attr = this.attributes[name];\n\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n\n            // For matrix attributes, buffer needs to be defined per column\n            let numLoc = 1;\n            if (type === 35674) numLoc = 2; // mat2\n            if (type === 35675) numLoc = 3; // mat3\n            if (type === 35676) numLoc = 4; // mat4\n\n            const size = attr.size / numLoc;\n            const stride = numLoc === 1 ? 0 : numLoc * numLoc * numLoc;\n            const offset = numLoc === 1 ? 0 : numLoc * numLoc;\n\n            for (let i = 0; i < numLoc; i++) {\n                this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n                this.gl.enableVertexAttribArray(location + i);\n\n                // For instanced attributes, divisor needs to be set.\n                // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n                this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n            }\n        });\n\n        // Bind indices if geometry indexed\n        if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n    }\n\n    draw({ program, mode = this.gl.TRIANGLES }) {\n        if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n            if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n            this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n            this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n        }\n\n        // Check if any attributes need updating\n        program.attributeLocations.forEach((location, { name }) => {\n            const attr = this.attributes[name];\n            if (attr.needsUpdate) this.updateAttribute(attr);\n        });\n\n        if (this.isInstanced) {\n            if (this.attributes.index) {\n                this.gl.renderer.drawElementsInstanced(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * 2,\n                    this.instancedCount\n                );\n            } else {\n                this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n            }\n        } else {\n            if (this.attributes.index) {\n                this.gl.drawElements(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * 2);\n            } else {\n                this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n            }\n        }\n    }\n\n    getPosition() {\n        // Use position buffer, or min/max if available\n        const attr = this.attributes.position;\n        // if (attr.min) return [...attr.min, ...attr.max];\n        if (attr.data) return attr;\n        if (isBoundsWarned) return;\n        console.warn('No position buffer data found to compute bounds');\n        return (isBoundsWarned = true);\n    }\n\n    computeBoundingBox(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        const stride = attr.stride || attr.size;\n\n        if (!this.bounds) {\n            this.bounds = {\n                min: new Vec3(),\n                max: new Vec3(),\n                center: new Vec3(),\n                scale: new Vec3(),\n                radius: Infinity,\n            };\n        }\n\n        const min = this.bounds.min;\n        const max = this.bounds.max;\n        const center = this.bounds.center;\n        const scale = this.bounds.scale;\n\n        min.set(+Infinity);\n        max.set(-Infinity);\n\n        // TODO: check size of position (eg triangle with Vec2)\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            const x = array[i];\n            const y = array[i + 1];\n            const z = array[i + 2];\n\n            min.x = Math.min(x, min.x);\n            min.y = Math.min(y, min.y);\n            min.z = Math.min(z, min.z);\n\n            max.x = Math.max(x, max.x);\n            max.y = Math.max(y, max.y);\n            max.z = Math.max(z, max.z);\n        }\n\n        scale.sub(max, min);\n        center.add(min, max).divide(2);\n    }\n\n    computeBoundingSphere(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        const stride = attr.stride || attr.size;\n\n        if (!this.bounds) this.computeBoundingBox(attr);\n\n        let maxRadiusSq = 0;\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            tempVec3.fromArray(array, i);\n            maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n        }\n\n        this.bounds.radius = Math.sqrt(maxRadiusSq);\n    }\n\n    remove() {\n        for (let key in this.VAOs) {\n            this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n            delete this.VAOs[key];\n        }\n        for (let key in this.attributes) {\n            this.gl.deleteBuffer(this.attributes[key].buffer);\n            delete this.attributes[key];\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}