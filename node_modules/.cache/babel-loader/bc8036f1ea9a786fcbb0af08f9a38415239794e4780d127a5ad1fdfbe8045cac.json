{"ast":null,"code":"import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\nconst tmpVec3A = new Vec3();\nconst tmpVec3B = new Vec3();\nconst tmpVec3C = new Vec3();\nconst tmpVec3D = new Vec3();\nconst tmpQuatA = new Quat();\nconst tmpQuatB = new Quat();\nconst tmpQuatC = new Quat();\nconst tmpQuatD = new Quat();\nexport class GLTFAnimation {\n  constructor(data) {\n    let weight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this.data = data;\n    this.elapsed = 0;\n    this.weight = weight;\n\n    // Set to false to not apply modulo to elapsed against duration\n    this.loop = true;\n\n    // Find starting time as exports from blender (perhaps others too) don't always start from 0\n    this.startTime = data.reduce((a, _ref) => {\n      let {\n        times\n      } = _ref;\n      return Math.min(a, times[0]);\n    }, Infinity);\n    // Get largest final time in all channels to calculate duration\n    this.endTime = data.reduce((a, _ref2) => {\n      let {\n        times\n      } = _ref2;\n      return Math.max(a, times[times.length - 1]);\n    }, 0);\n    this.duration = this.endTime - this.startTime;\n  }\n  update() {\n    let totalWeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let isSet = arguments.length > 1 ? arguments[1] : undefined;\n    const weight = isSet ? 1 : this.weight / totalWeight;\n    const elapsed = (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n    this.data.forEach(_ref3 => {\n      let {\n        node,\n        transform,\n        interpolation,\n        times,\n        values\n      } = _ref3;\n      // Get index of two time values elapsed is between\n      const prevIndex = Math.max(1, times.findIndex(t => t > elapsed)) - 1;\n      const nextIndex = prevIndex + 1;\n\n      // Get linear blend/alpha between the two\n      let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n      if (interpolation === 'STEP') alpha = 0;\n      let prevVal = tmpVec3A;\n      let prevTan = tmpVec3B;\n      let nextTan = tmpVec3C;\n      let nextVal = tmpVec3D;\n      let size = 3;\n      if (transform === 'quaternion') {\n        prevVal = tmpQuatA;\n        prevTan = tmpQuatB;\n        nextTan = tmpQuatC;\n        nextVal = tmpQuatD;\n        size = 4;\n      }\n      if (interpolation === 'CUBICSPLINE') {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n        prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n        nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n        nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n        // interpolate for final value\n        prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n        if (size === 4) prevVal.normalize();\n      } else {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size);\n        nextVal.fromArray(values, nextIndex * size);\n\n        // interpolate for final value\n        if (size === 4) prevVal.slerp(nextVal, alpha);else prevVal.lerp(nextVal, alpha);\n      }\n\n      // interpolate between multiple possible animations\n      if (size === 4) node[transform].slerp(prevVal, weight);else node[transform].lerp(prevVal, weight);\n    });\n  }\n  cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n    const s2 = 3 * t2 - 2 * t3;\n    const s3 = t3 - t2;\n    const s0 = 1 - s2;\n    const s1 = s3 - t2 + t;\n    for (let i = 0; i < prevVal.length; i++) {\n      prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n    }\n    return prevVal;\n  }\n}","map":{"version":3,"names":["Vec3","Quat","tmpVec3A","tmpVec3B","tmpVec3C","tmpVec3D","tmpQuatA","tmpQuatB","tmpQuatC","tmpQuatD","GLTFAnimation","constructor","data","weight","arguments","length","undefined","elapsed","loop","startTime","reduce","a","_ref","times","Math","min","Infinity","endTime","_ref2","max","duration","update","totalWeight","isSet","forEach","_ref3","node","transform","interpolation","values","prevIndex","findIndex","t","nextIndex","alpha","prevVal","prevTan","nextTan","nextVal","size","fromArray","cubicSplineInterpolate","normalize","slerp","lerp","t2","t3","s2","s3","s0","s1","i"],"sources":["/Users/krishnapandey/Desktop/Codevo/node_modules/ogl/src/extras/GLTFAnimation.js"],"sourcesContent":["import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst tmpVec3A = new Vec3();\nconst tmpVec3B = new Vec3();\nconst tmpVec3C = new Vec3();\nconst tmpVec3D = new Vec3();\n\nconst tmpQuatA = new Quat();\nconst tmpQuatB = new Quat();\nconst tmpQuatC = new Quat();\nconst tmpQuatD = new Quat();\n\nexport class GLTFAnimation {\n    constructor(data, weight = 1) {\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = weight;\n\n        // Set to false to not apply modulo to elapsed against duration\n        this.loop = true;\n\n        // Find starting time as exports from blender (perhaps others too) don't always start from 0\n        this.startTime = data.reduce((a, { times }) => Math.min(a, times[0]), Infinity);\n        // Get largest final time in all channels to calculate duration\n        this.endTime = data.reduce((a, { times }) => Math.max(a, times[times.length - 1]), 0);\n        this.duration = this.endTime - this.startTime;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n\n        this.data.forEach(({ node, transform, interpolation, times, values }) => {\n            // Get index of two time values elapsed is between\n            const prevIndex =\n                Math.max(\n                    1,\n                    times.findIndex((t) => t > elapsed)\n                ) - 1;\n            const nextIndex = prevIndex + 1;\n\n            // Get linear blend/alpha between the two\n            let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n            if (interpolation === 'STEP') alpha = 0;\n\n            let prevVal = tmpVec3A;\n            let prevTan = tmpVec3B;\n            let nextTan = tmpVec3C;\n            let nextVal = tmpVec3D;\n            let size = 3;\n\n            if (transform === 'quaternion') {\n                prevVal = tmpQuatA;\n                prevTan = tmpQuatB;\n                nextTan = tmpQuatC;\n                nextVal = tmpQuatD;\n                size = 4;\n            }\n\n            if (interpolation === 'CUBICSPLINE') {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n                prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n                nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n                nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n                // interpolate for final value\n                prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n                if (size === 4) prevVal.normalize();\n            } else {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size);\n                nextVal.fromArray(values, nextIndex * size);\n\n                // interpolate for final value\n                if (size === 4) prevVal.slerp(nextVal, alpha);\n                else prevVal.lerp(nextVal, alpha);\n            }\n\n            // interpolate between multiple possible animations\n            if (size === 4) node[transform].slerp(prevVal, weight);\n            else node[transform].lerp(prevVal, weight);\n        });\n    }\n\n    cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n\n        const s2 = 3 * t2 - 2 * t3;\n        const s3 = t3 - t2;\n        const s0 = 1 - s2;\n        const s1 = s3 - t2 + t;\n\n        for (let i = 0; i < prevVal.length; i++) {\n            prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n        }\n\n        return prevVal;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}