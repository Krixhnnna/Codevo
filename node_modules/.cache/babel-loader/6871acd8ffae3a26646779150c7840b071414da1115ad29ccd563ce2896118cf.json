{"ast":null,"code":"// TODO: barycentric code shouldn't be here, but where?\n// TODO: SphereCast?\n\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Mat4 } from '../math/Mat4.js';\nconst tempVec2a = new Vec2();\nconst tempVec2b = new Vec2();\nconst tempVec2c = new Vec2();\nconst tempVec3a = new Vec3();\nconst tempVec3b = new Vec3();\nconst tempVec3c = new Vec3();\nconst tempVec3d = new Vec3();\nconst tempVec3e = new Vec3();\nconst tempVec3f = new Vec3();\nconst tempVec3g = new Vec3();\nconst tempVec3h = new Vec3();\nconst tempVec3i = new Vec3();\nconst tempVec3j = new Vec3();\nconst tempVec3k = new Vec3();\nconst tempMat4 = new Mat4();\nexport class Raycast {\n  constructor() {\n    this.origin = new Vec3();\n    this.direction = new Vec3();\n  }\n\n  // Set ray from mouse unprojection\n  castMouse(camera) {\n    let mouse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n    if (camera.type === 'orthographic') {\n      // Set origin\n      // Since camera is orthographic, origin is not the camera position\n      const {\n        left,\n        right,\n        bottom,\n        top,\n        zoom\n      } = camera;\n      const x = left / zoom + (right - left) / zoom * (mouse[0] * 0.5 + 0.5);\n      const y = bottom / zoom + (top - bottom) / zoom * (mouse[1] * 0.5 + 0.5);\n      this.origin.set(x, y, 0);\n      this.origin.applyMatrix4(camera.worldMatrix);\n\n      // Set direction\n      // https://community.khronos.org/t/get-direction-from-transformation-matrix-or-quat/65502/2\n      this.direction.x = -camera.worldMatrix[8];\n      this.direction.y = -camera.worldMatrix[9];\n      this.direction.z = -camera.worldMatrix[10];\n    } else {\n      // Set origin\n      camera.worldMatrix.getTranslation(this.origin);\n\n      // Set direction\n      this.direction.set(mouse[0], mouse[1], 0.5);\n      camera.unproject(this.direction);\n      this.direction.sub(this.origin).normalize();\n    }\n  }\n  intersectBounds(meshes) {\n    let {\n      maxDistance,\n      output = []\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!Array.isArray(meshes)) meshes = [meshes];\n    const invWorldMat4 = tempMat4;\n    const origin = tempVec3a;\n    const direction = tempVec3b;\n    const hits = output;\n    hits.length = 0;\n    meshes.forEach(mesh => {\n      // Create bounds\n      if (!mesh.geometry.bounds || mesh.geometry.bounds.radius === Infinity) mesh.geometry.computeBoundingSphere();\n      const bounds = mesh.geometry.bounds;\n      invWorldMat4.inverse(mesh.worldMatrix);\n\n      // Get max distance locally\n      let localMaxDistance;\n      if (maxDistance) {\n        direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n        localMaxDistance = maxDistance * direction.len();\n      }\n\n      // Take world space ray and make it object space to align with bounding box\n      origin.copy(this.origin).applyMatrix4(invWorldMat4);\n      direction.copy(this.direction).transformDirection(invWorldMat4);\n\n      // Break out early if bounds too far away from origin\n      if (maxDistance) {\n        if (origin.distance(bounds.center) - bounds.radius > localMaxDistance) return;\n      }\n      let localDistance = 0;\n\n      // Check origin isn't inside bounds before testing intersection\n      if (mesh.geometry.raycast === 'sphere') {\n        if (origin.distance(bounds.center) > bounds.radius) {\n          localDistance = this.intersectSphere(bounds, origin, direction);\n          if (!localDistance) return;\n        }\n      } else {\n        if (origin.x < bounds.min.x || origin.x > bounds.max.x || origin.y < bounds.min.y || origin.y > bounds.max.y || origin.z < bounds.min.z || origin.z > bounds.max.z) {\n          localDistance = this.intersectBox(bounds, origin, direction);\n          if (!localDistance) return;\n        }\n      }\n      if (maxDistance && localDistance > localMaxDistance) return;\n\n      // Create object on mesh to avoid generating lots of objects\n      if (!mesh.hit) mesh.hit = {\n        localPoint: new Vec3(),\n        point: new Vec3()\n      };\n      mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n      mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n      mesh.hit.distance = mesh.hit.point.distance(this.origin);\n      hits.push(mesh);\n    });\n    hits.sort((a, b) => a.hit.distance - b.hit.distance);\n    return hits;\n  }\n  intersectMeshes(meshes) {\n    let {\n      cullFace = true,\n      maxDistance,\n      includeUV = true,\n      includeNormal = true,\n      output = []\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Test bounds first before testing geometry\n    const hits = this.intersectBounds(meshes, {\n      maxDistance,\n      output\n    });\n    if (!hits.length) return hits;\n    const invWorldMat4 = tempMat4;\n    const origin = tempVec3a;\n    const direction = tempVec3b;\n    const a = tempVec3c;\n    const b = tempVec3d;\n    const c = tempVec3e;\n    const closestFaceNormal = tempVec3f;\n    const faceNormal = tempVec3g;\n    const barycoord = tempVec3h;\n    const uvA = tempVec2a;\n    const uvB = tempVec2b;\n    const uvC = tempVec2c;\n    for (let i = hits.length - 1; i >= 0; i--) {\n      const mesh = hits[i];\n      invWorldMat4.inverse(mesh.worldMatrix);\n\n      // Get max distance locally\n      let localMaxDistance;\n      if (maxDistance) {\n        direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n        localMaxDistance = maxDistance * direction.len();\n      }\n\n      // Take world space ray and make it object space to align with bounding box\n      origin.copy(this.origin).applyMatrix4(invWorldMat4);\n      direction.copy(this.direction).transformDirection(invWorldMat4);\n      let localDistance = 0;\n      let closestA, closestB, closestC;\n      const geometry = mesh.geometry;\n      const attributes = geometry.attributes;\n      const index = attributes.index;\n      const start = Math.max(0, geometry.drawRange.start);\n      const end = Math.min(index ? index.count : attributes.position.count, geometry.drawRange.start + geometry.drawRange.count);\n      for (let j = start; j < end; j += 3) {\n        // Position attribute indices for each triangle\n        const ai = index ? index.data[j] : j;\n        const bi = index ? index.data[j + 1] : j + 1;\n        const ci = index ? index.data[j + 2] : j + 2;\n        a.fromArray(attributes.position.data, ai * 3);\n        b.fromArray(attributes.position.data, bi * 3);\n        c.fromArray(attributes.position.data, ci * 3);\n        const distance = this.intersectTriangle(a, b, c, cullFace, origin, direction, faceNormal);\n        if (!distance) continue;\n\n        // Too far away\n        if (maxDistance && distance > localMaxDistance) continue;\n        if (!localDistance || distance < localDistance) {\n          localDistance = distance;\n          closestA = ai;\n          closestB = bi;\n          closestC = ci;\n          closestFaceNormal.copy(faceNormal);\n        }\n      }\n      if (!localDistance) hits.splice(i, 1);\n\n      // Update hit values from bounds-test\n      mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n      mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n      mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n      // Add unique hit objects on mesh to avoid generating lots of objects\n      if (!mesh.hit.faceNormal) {\n        mesh.hit.localFaceNormal = new Vec3();\n        mesh.hit.faceNormal = new Vec3();\n        mesh.hit.uv = new Vec2();\n        mesh.hit.localNormal = new Vec3();\n        mesh.hit.normal = new Vec3();\n      }\n\n      // Add face normal data which is already computed\n      mesh.hit.localFaceNormal.copy(closestFaceNormal);\n      mesh.hit.faceNormal.copy(mesh.hit.localFaceNormal).transformDirection(mesh.worldMatrix);\n\n      // Optional data, opt out to optimise a bit if necessary\n      if (includeUV || includeNormal) {\n        // Calculate barycoords to find uv values at hit point\n        a.fromArray(attributes.position.data, closestA * 3);\n        b.fromArray(attributes.position.data, closestB * 3);\n        c.fromArray(attributes.position.data, closestC * 3);\n        this.getBarycoord(mesh.hit.localPoint, a, b, c, barycoord);\n      }\n      if (includeUV && attributes.uv) {\n        uvA.fromArray(attributes.uv.data, closestA * 2);\n        uvB.fromArray(attributes.uv.data, closestB * 2);\n        uvC.fromArray(attributes.uv.data, closestC * 2);\n        mesh.hit.uv.set(uvA.x * barycoord.x + uvB.x * barycoord.y + uvC.x * barycoord.z, uvA.y * barycoord.x + uvB.y * barycoord.y + uvC.y * barycoord.z);\n      }\n      if (includeNormal && attributes.normal) {\n        a.fromArray(attributes.normal.data, closestA * 3);\n        b.fromArray(attributes.normal.data, closestB * 3);\n        c.fromArray(attributes.normal.data, closestC * 3);\n        mesh.hit.localNormal.set(a.x * barycoord.x + b.x * barycoord.y + c.x * barycoord.z, a.y * barycoord.x + b.y * barycoord.y + c.y * barycoord.z, a.z * barycoord.x + b.z * barycoord.y + c.z * barycoord.z);\n        mesh.hit.normal.copy(mesh.hit.localNormal).transformDirection(mesh.worldMatrix);\n      }\n    }\n    hits.sort((a, b) => a.hit.distance - b.hit.distance);\n    return hits;\n  }\n  intersectSphere(sphere) {\n    let origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.origin;\n    let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.direction;\n    const ray = tempVec3c;\n    ray.sub(sphere.center, origin);\n    const tca = ray.dot(direction);\n    const d2 = ray.dot(ray) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2) return 0;\n    const thc = Math.sqrt(radius2 - d2);\n    const t0 = tca - thc;\n    const t1 = tca + thc;\n    if (t0 < 0 && t1 < 0) return 0;\n    if (t0 < 0) return t1;\n    return t0;\n  }\n\n  // Ray AABB - Ray Axis aligned bounding box testing\n  intersectBox(box) {\n    let origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.origin;\n    let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.direction;\n    let tmin, tmax, tYmin, tYmax, tZmin, tZmax;\n    const invdirx = 1 / direction.x;\n    const invdiry = 1 / direction.y;\n    const invdirz = 1 / direction.z;\n    const min = box.min;\n    const max = box.max;\n    tmin = ((invdirx >= 0 ? min.x : max.x) - origin.x) * invdirx;\n    tmax = ((invdirx >= 0 ? max.x : min.x) - origin.x) * invdirx;\n    tYmin = ((invdiry >= 0 ? min.y : max.y) - origin.y) * invdiry;\n    tYmax = ((invdiry >= 0 ? max.y : min.y) - origin.y) * invdiry;\n    if (tmin > tYmax || tYmin > tmax) return 0;\n    if (tYmin > tmin) tmin = tYmin;\n    if (tYmax < tmax) tmax = tYmax;\n    tZmin = ((invdirz >= 0 ? min.z : max.z) - origin.z) * invdirz;\n    tZmax = ((invdirz >= 0 ? max.z : min.z) - origin.z) * invdirz;\n    if (tmin > tZmax || tZmin > tmax) return 0;\n    if (tZmin > tmin) tmin = tZmin;\n    if (tZmax < tmax) tmax = tZmax;\n    if (tmax < 0) return 0;\n    return tmin >= 0 ? tmin : tmax;\n  }\n  intersectTriangle(a, b, c) {\n    let backfaceCulling = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let origin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.origin;\n    let direction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.direction;\n    let normal = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : tempVec3g;\n    // from https://github.com/mrdoob/three.js/blob/master/src/math/Ray.js\n    // which is from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n    const edge1 = tempVec3h;\n    const edge2 = tempVec3i;\n    const diff = tempVec3j;\n    edge1.sub(b, a);\n    edge2.sub(c, a);\n    normal.cross(edge1, edge2);\n    let DdN = direction.dot(normal);\n    if (!DdN) return 0;\n    let sign;\n    if (DdN > 0) {\n      if (backfaceCulling) return 0;\n      sign = 1;\n    } else {\n      sign = -1;\n      DdN = -DdN;\n    }\n    diff.sub(origin, a);\n    let DdQxE2 = sign * direction.dot(edge2.cross(diff, edge2));\n    if (DdQxE2 < 0) return 0;\n    let DdE1xQ = sign * direction.dot(edge1.cross(diff));\n    if (DdE1xQ < 0) return 0;\n    if (DdQxE2 + DdE1xQ > DdN) return 0;\n    let QdN = -sign * diff.dot(normal);\n    if (QdN < 0) return 0;\n    return QdN / DdN;\n  }\n  getBarycoord(point, a, b, c) {\n    let target = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : tempVec3h;\n    // From https://github.com/mrdoob/three.js/blob/master/src/math/Triangle.js\n    // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n    const v0 = tempVec3i;\n    const v1 = tempVec3j;\n    const v2 = tempVec3k;\n    v0.sub(c, a);\n    v1.sub(b, a);\n    v2.sub(point, a);\n    const dot00 = v0.dot(v0);\n    const dot01 = v0.dot(v1);\n    const dot02 = v0.dot(v2);\n    const dot11 = v1.dot(v1);\n    const dot12 = v1.dot(v2);\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if (denom === 0) return target.set(-2, -1, -1);\n    const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return target.set(1 - u - v, v, u);\n  }\n}","map":{"version":3,"names":["Vec2","Vec3","Mat4","tempVec2a","tempVec2b","tempVec2c","tempVec3a","tempVec3b","tempVec3c","tempVec3d","tempVec3e","tempVec3f","tempVec3g","tempVec3h","tempVec3i","tempVec3j","tempVec3k","tempMat4","Raycast","constructor","origin","direction","castMouse","camera","mouse","arguments","length","undefined","type","left","right","bottom","top","zoom","x","y","set","applyMatrix4","worldMatrix","z","getTranslation","unproject","sub","normalize","intersectBounds","meshes","maxDistance","output","Array","isArray","invWorldMat4","hits","forEach","mesh","geometry","bounds","radius","Infinity","computeBoundingSphere","inverse","localMaxDistance","copy","scaleRotateMatrix4","len","transformDirection","distance","center","localDistance","raycast","intersectSphere","min","max","intersectBox","hit","localPoint","point","multiply","add","push","sort","a","b","intersectMeshes","cullFace","includeUV","includeNormal","c","closestFaceNormal","faceNormal","barycoord","uvA","uvB","uvC","i","closestA","closestB","closestC","attributes","index","start","Math","drawRange","end","count","position","j","ai","data","bi","ci","fromArray","intersectTriangle","splice","localFaceNormal","uv","localNormal","normal","getBarycoord","sphere","ray","tca","dot","d2","radius2","thc","sqrt","t0","t1","box","tmin","tmax","tYmin","tYmax","tZmin","tZmax","invdirx","invdiry","invdirz","backfaceCulling","edge1","edge2","diff","cross","DdN","sign","DdQxE2","DdE1xQ","QdN","target","v0","v1","v2","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","v"],"sources":["/Users/krishnapandey/Desktop/Codevo/node_modules/ogl/src/extras/Raycast.js"],"sourcesContent":["// TODO: barycentric code shouldn't be here, but where?\n// TODO: SphereCast?\n\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nconst tempVec2a = new Vec2();\nconst tempVec2b = new Vec2();\nconst tempVec2c = new Vec2();\n\nconst tempVec3a = new Vec3();\nconst tempVec3b = new Vec3();\nconst tempVec3c = new Vec3();\nconst tempVec3d = new Vec3();\nconst tempVec3e = new Vec3();\nconst tempVec3f = new Vec3();\nconst tempVec3g = new Vec3();\nconst tempVec3h = new Vec3();\nconst tempVec3i = new Vec3();\nconst tempVec3j = new Vec3();\nconst tempVec3k = new Vec3();\n\nconst tempMat4 = new Mat4();\n\nexport class Raycast {\n    constructor() {\n        this.origin = new Vec3();\n        this.direction = new Vec3();\n    }\n\n    // Set ray from mouse unprojection\n    castMouse(camera, mouse = [0, 0]) {\n        if (camera.type === 'orthographic') {\n            // Set origin\n            // Since camera is orthographic, origin is not the camera position\n            const { left, right, bottom, top, zoom } = camera;\n            const x = left / zoom + ((right - left) / zoom) * (mouse[0] * 0.5 + 0.5);\n            const y = bottom / zoom + ((top - bottom) / zoom) * (mouse[1] * 0.5 + 0.5);\n            this.origin.set(x, y, 0);\n            this.origin.applyMatrix4(camera.worldMatrix);\n\n            // Set direction\n            // https://community.khronos.org/t/get-direction-from-transformation-matrix-or-quat/65502/2\n            this.direction.x = -camera.worldMatrix[8];\n            this.direction.y = -camera.worldMatrix[9];\n            this.direction.z = -camera.worldMatrix[10];\n        } else {\n            // Set origin\n            camera.worldMatrix.getTranslation(this.origin);\n\n            // Set direction\n            this.direction.set(mouse[0], mouse[1], 0.5);\n            camera.unproject(this.direction);\n            this.direction.sub(this.origin).normalize();\n        }\n    }\n\n    intersectBounds(meshes, { maxDistance, output = [] } = {}) {\n        if (!Array.isArray(meshes)) meshes = [meshes];\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n\n        const hits = output;\n        hits.length = 0;\n\n        meshes.forEach((mesh) => {\n            // Create bounds\n            if (!mesh.geometry.bounds || mesh.geometry.bounds.radius === Infinity) mesh.geometry.computeBoundingSphere();\n            const bounds = mesh.geometry.bounds;\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            // Break out early if bounds too far away from origin\n            if (maxDistance) {\n                if (origin.distance(bounds.center) - bounds.radius > localMaxDistance) return;\n            }\n\n            let localDistance = 0;\n\n            // Check origin isn't inside bounds before testing intersection\n            if (mesh.geometry.raycast === 'sphere') {\n                if (origin.distance(bounds.center) > bounds.radius) {\n                    localDistance = this.intersectSphere(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            } else {\n                if (\n                    origin.x < bounds.min.x ||\n                    origin.x > bounds.max.x ||\n                    origin.y < bounds.min.y ||\n                    origin.y > bounds.max.y ||\n                    origin.z < bounds.min.z ||\n                    origin.z > bounds.max.z\n                ) {\n                    localDistance = this.intersectBox(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            }\n\n            if (maxDistance && localDistance > localMaxDistance) return;\n\n            // Create object on mesh to avoid generating lots of objects\n            if (!mesh.hit) mesh.hit = { localPoint: new Vec3(), point: new Vec3() };\n\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            hits.push(mesh);\n        });\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectMeshes(meshes, { cullFace = true, maxDistance, includeUV = true, includeNormal = true, output = [] } = {}) {\n        // Test bounds first before testing geometry\n        const hits = this.intersectBounds(meshes, { maxDistance, output });\n        if (!hits.length) return hits;\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n        const a = tempVec3c;\n        const b = tempVec3d;\n        const c = tempVec3e;\n        const closestFaceNormal = tempVec3f;\n        const faceNormal = tempVec3g;\n        const barycoord = tempVec3h;\n        const uvA = tempVec2a;\n        const uvB = tempVec2b;\n        const uvC = tempVec2c;\n\n        for (let i = hits.length - 1; i >= 0; i--) {\n            const mesh = hits[i];\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            let localDistance = 0;\n            let closestA, closestB, closestC;\n\n            const geometry = mesh.geometry;\n            const attributes = geometry.attributes;\n            const index = attributes.index;\n\n            const start = Math.max(0, geometry.drawRange.start);\n            const end = Math.min(index ? index.count : attributes.position.count, geometry.drawRange.start + geometry.drawRange.count);\n\n            for (let j = start; j < end; j += 3) {\n                // Position attribute indices for each triangle\n                const ai = index ? index.data[j] : j;\n                const bi = index ? index.data[j + 1] : j + 1;\n                const ci = index ? index.data[j + 2] : j + 2;\n\n                a.fromArray(attributes.position.data, ai * 3);\n                b.fromArray(attributes.position.data, bi * 3);\n                c.fromArray(attributes.position.data, ci * 3);\n\n                const distance = this.intersectTriangle(a, b, c, cullFace, origin, direction, faceNormal);\n                if (!distance) continue;\n\n                // Too far away\n                if (maxDistance && distance > localMaxDistance) continue;\n\n                if (!localDistance || distance < localDistance) {\n                    localDistance = distance;\n                    closestA = ai;\n                    closestB = bi;\n                    closestC = ci;\n                    closestFaceNormal.copy(faceNormal);\n                }\n            }\n\n            if (!localDistance) hits.splice(i, 1);\n\n            // Update hit values from bounds-test\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            // Add unique hit objects on mesh to avoid generating lots of objects\n            if (!mesh.hit.faceNormal) {\n                mesh.hit.localFaceNormal = new Vec3();\n                mesh.hit.faceNormal = new Vec3();\n                mesh.hit.uv = new Vec2();\n                mesh.hit.localNormal = new Vec3();\n                mesh.hit.normal = new Vec3();\n            }\n\n            // Add face normal data which is already computed\n            mesh.hit.localFaceNormal.copy(closestFaceNormal);\n            mesh.hit.faceNormal.copy(mesh.hit.localFaceNormal).transformDirection(mesh.worldMatrix);\n\n            // Optional data, opt out to optimise a bit if necessary\n            if (includeUV || includeNormal) {\n                // Calculate barycoords to find uv values at hit point\n                a.fromArray(attributes.position.data, closestA * 3);\n                b.fromArray(attributes.position.data, closestB * 3);\n                c.fromArray(attributes.position.data, closestC * 3);\n                this.getBarycoord(mesh.hit.localPoint, a, b, c, barycoord);\n            }\n\n            if (includeUV && attributes.uv) {\n                uvA.fromArray(attributes.uv.data, closestA * 2);\n                uvB.fromArray(attributes.uv.data, closestB * 2);\n                uvC.fromArray(attributes.uv.data, closestC * 2);\n                mesh.hit.uv.set(\n                    uvA.x * barycoord.x + uvB.x * barycoord.y + uvC.x * barycoord.z,\n                    uvA.y * barycoord.x + uvB.y * barycoord.y + uvC.y * barycoord.z\n                );\n            }\n\n            if (includeNormal && attributes.normal) {\n                a.fromArray(attributes.normal.data, closestA * 3);\n                b.fromArray(attributes.normal.data, closestB * 3);\n                c.fromArray(attributes.normal.data, closestC * 3);\n                mesh.hit.localNormal.set(\n                    a.x * barycoord.x + b.x * barycoord.y + c.x * barycoord.z,\n                    a.y * barycoord.x + b.y * barycoord.y + c.y * barycoord.z,\n                    a.z * barycoord.x + b.z * barycoord.y + c.z * barycoord.z\n                );\n\n                mesh.hit.normal.copy(mesh.hit.localNormal).transformDirection(mesh.worldMatrix);\n            }\n        }\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectSphere(sphere, origin = this.origin, direction = this.direction) {\n        const ray = tempVec3c;\n        ray.sub(sphere.center, origin);\n        const tca = ray.dot(direction);\n        const d2 = ray.dot(ray) - tca * tca;\n        const radius2 = sphere.radius * sphere.radius;\n        if (d2 > radius2) return 0;\n        const thc = Math.sqrt(radius2 - d2);\n        const t0 = tca - thc;\n        const t1 = tca + thc;\n        if (t0 < 0 && t1 < 0) return 0;\n        if (t0 < 0) return t1;\n        return t0;\n    }\n\n    // Ray AABB - Ray Axis aligned bounding box testing\n    intersectBox(box, origin = this.origin, direction = this.direction) {\n        let tmin, tmax, tYmin, tYmax, tZmin, tZmax;\n        const invdirx = 1 / direction.x;\n        const invdiry = 1 / direction.y;\n        const invdirz = 1 / direction.z;\n        const min = box.min;\n        const max = box.max;\n        tmin = ((invdirx >= 0 ? min.x : max.x) - origin.x) * invdirx;\n        tmax = ((invdirx >= 0 ? max.x : min.x) - origin.x) * invdirx;\n        tYmin = ((invdiry >= 0 ? min.y : max.y) - origin.y) * invdiry;\n        tYmax = ((invdiry >= 0 ? max.y : min.y) - origin.y) * invdiry;\n        if (tmin > tYmax || tYmin > tmax) return 0;\n        if (tYmin > tmin) tmin = tYmin;\n        if (tYmax < tmax) tmax = tYmax;\n        tZmin = ((invdirz >= 0 ? min.z : max.z) - origin.z) * invdirz;\n        tZmax = ((invdirz >= 0 ? max.z : min.z) - origin.z) * invdirz;\n        if (tmin > tZmax || tZmin > tmax) return 0;\n        if (tZmin > tmin) tmin = tZmin;\n        if (tZmax < tmax) tmax = tZmax;\n        if (tmax < 0) return 0;\n        return tmin >= 0 ? tmin : tmax;\n    }\n\n    intersectTriangle(a, b, c, backfaceCulling = true, origin = this.origin, direction = this.direction, normal = tempVec3g) {\n        // from https://github.com/mrdoob/three.js/blob/master/src/math/Ray.js\n        // which is from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n        const edge1 = tempVec3h;\n        const edge2 = tempVec3i;\n        const diff = tempVec3j;\n        edge1.sub(b, a);\n        edge2.sub(c, a);\n        normal.cross(edge1, edge2);\n        let DdN = direction.dot(normal);\n        if (!DdN) return 0;\n        let sign;\n        if (DdN > 0) {\n            if (backfaceCulling) return 0;\n            sign = 1;\n        } else {\n            sign = -1;\n            DdN = -DdN;\n        }\n        diff.sub(origin, a);\n        let DdQxE2 = sign * direction.dot(edge2.cross(diff, edge2));\n        if (DdQxE2 < 0) return 0;\n        let DdE1xQ = sign * direction.dot(edge1.cross(diff));\n        if (DdE1xQ < 0) return 0;\n        if (DdQxE2 + DdE1xQ > DdN) return 0;\n        let QdN = -sign * diff.dot(normal);\n        if (QdN < 0) return 0;\n        return QdN / DdN;\n    }\n\n    getBarycoord(point, a, b, c, target = tempVec3h) {\n        // From https://github.com/mrdoob/three.js/blob/master/src/math/Triangle.js\n        // static/instance method to calculate barycentric coordinates\n        // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n        const v0 = tempVec3i;\n        const v1 = tempVec3j;\n        const v2 = tempVec3k;\n        v0.sub(c, a);\n        v1.sub(b, a);\n        v2.sub(point, a);\n        const dot00 = v0.dot(v0);\n        const dot01 = v0.dot(v1);\n        const dot02 = v0.dot(v2);\n        const dot11 = v1.dot(v1);\n        const dot12 = v1.dot(v2);\n        const denom = dot00 * dot11 - dot01 * dot01;\n        if (denom === 0) return target.set(-2, -1, -1);\n        const invDenom = 1 / denom;\n        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n        return target.set(1 - u - v, v, u);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}