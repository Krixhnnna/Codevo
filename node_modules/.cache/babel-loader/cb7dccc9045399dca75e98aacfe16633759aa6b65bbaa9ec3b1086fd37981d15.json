{"ast":null,"code":"import { Geometry } from '../core/Geometry.js';\nimport { Transform } from '../core/Transform.js';\nimport { Texture } from '../core/Texture.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { GLTFAnimation } from './GLTFAnimation.js';\nimport { GLTFSkin } from './GLTFSkin.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { NormalProgram } from './NormalProgram.js';\n\n// Supports\n// [x] Geometry\n// [ ] Sparse support\n// [x] Nodes and Hierarchy\n// [x] Instancing\n// [ ] Morph Targets\n// [x] Skins\n// [ ] Materials\n// [x] Textures\n// [x] Animation\n// [ ] Cameras\n// [ ] Extensions\n// [x] GLB support\n// [x] Basis/ktx2 support\n\n// TODO: Sparse accessor packing? For morph targets basically\n// TODO: init accessor missing bufferView with 0s\n// TODO: morph target animations\n// TODO: what to do if multiple instances are in different groups? Only uses local matrices\n// TODO: what if instancing isn't wanted? Eg collision maps\n// TODO: ie11 fallback for TextDecoder?\n\nconst TYPE_ARRAY = {\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n  'image/jpeg': Uint8Array,\n  'image/png': Uint8Array\n};\nconst TYPE_SIZE = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  TEXCOORD_0: 'uv',\n  TEXCOORD_1: 'uv2',\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex'\n};\nconst TRANSFORMS = {\n  translation: 'position',\n  rotation: 'quaternion',\n  scale: 'scale'\n};\nexport class GLTFLoader {\n  static setBasisManager(manager) {\n    this.basisManager = manager;\n  }\n  static async load(gl, src) {\n    const dir = src.split('/').slice(0, -1).join('/') + '/';\n\n    // load main description json\n    const desc = await this.parseDesc(src);\n    return await this.parse(gl, desc, dir);\n  }\n  static async parse(gl, desc, dir) {\n    var _desc$extensionsRequi;\n    if (desc.asset === undefined || desc.asset.version[0] < 2) console.warn('Only GLTF >=2.0 supported. Attempting to parse.');\n    if ((_desc$extensionsRequi = desc.extensionsRequired) !== null && _desc$extensionsRequi !== void 0 && _desc$extensionsRequi.includes('KHR_texture_basisu') && !this.basisManager) console.warn('KHR_texture_basisu extension required but no manager supplied. Use .setBasisManager()');\n\n    // Load buffers async\n    const buffers = await this.loadBuffers(desc, dir);\n\n    // Unbind current VAO so that new buffers don't get added to active mesh\n    gl.renderer.bindVertexArray(null);\n\n    // Create gl buffers from bufferViews\n    const bufferViews = this.parseBufferViews(gl, desc, buffers);\n\n    // Create images from either bufferViews or separate image files\n    const images = await this.parseImages(gl, desc, dir, bufferViews);\n    const textures = this.parseTextures(gl, desc, images);\n\n    // Just pass through material data for now\n    const materials = this.parseMaterials(gl, desc, textures);\n\n    // Fetch the inverse bind matrices for skeleton joints\n    const skins = this.parseSkins(gl, desc, bufferViews);\n\n    // Create geometries for each mesh primitive\n    const meshes = this.parseMeshes(gl, desc, bufferViews, materials, skins);\n\n    // Create transforms, meshes and hierarchy\n    const nodes = this.parseNodes(gl, desc, meshes, skins);\n\n    // Place nodes in skeletons\n    this.populateSkins(skins, nodes);\n\n    // Create animation handlers\n    const animations = this.parseAnimations(gl, desc, nodes, bufferViews);\n\n    // Get top level nodes for each scene\n    const scenes = this.parseScenes(desc, nodes);\n    const scene = scenes[desc.scene];\n\n    // Remove null nodes (instanced transforms)\n    for (let i = nodes.length; i >= 0; i--) if (!nodes[i]) nodes.splice(i, 1);\n    return {\n      json: desc,\n      buffers,\n      bufferViews,\n      images,\n      textures,\n      materials,\n      meshes,\n      nodes,\n      animations,\n      scenes,\n      scene\n    };\n  }\n  static async parseDesc(src) {\n    if (!src.match(/\\.glb/)) {\n      return await fetch(src).then(res => res.json());\n    } else {\n      return await fetch(src).then(res => res.arrayBuffer()).then(glb => this.unpackGLB(glb));\n    }\n  }\n\n  // From https://github.com/donmccurdy/glTF-Transform/blob/e4108cc/packages/core/src/io/io.ts#L32\n  static unpackGLB(glb) {\n    // Decode and verify GLB header.\n    const header = new Uint32Array(glb, 0, 3);\n    if (header[0] !== 0x46546c67) {\n      throw new Error('Invalid glTF asset.');\n    } else if (header[1] !== 2) {\n      throw new Error(\"Unsupported glTF binary version, \\\"\".concat(header[1], \"\\\".\"));\n    }\n    // Decode and verify chunk headers.\n    const jsonChunkHeader = new Uint32Array(glb, 12, 2);\n    const jsonByteOffset = 20;\n    const jsonByteLength = jsonChunkHeader[0];\n    if (jsonChunkHeader[1] !== 0x4e4f534a) {\n      throw new Error('Unexpected GLB layout.');\n    }\n\n    // Decode JSON.\n    const jsonText = new TextDecoder().decode(glb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength));\n    const json = JSON.parse(jsonText);\n    // JSON only\n    if (jsonByteOffset + jsonByteLength === glb.byteLength) return json;\n    const binaryChunkHeader = new Uint32Array(glb, jsonByteOffset + jsonByteLength, 2);\n    if (binaryChunkHeader[1] !== 0x004e4942) {\n      throw new Error('Unexpected GLB layout.');\n    }\n    // Decode content.\n    const binaryByteOffset = jsonByteOffset + jsonByteLength + 8;\n    const binaryByteLength = binaryChunkHeader[0];\n    const binary = glb.slice(binaryByteOffset, binaryByteOffset + binaryByteLength);\n    // Attach binary to buffer\n    json.buffers[0].binary = binary;\n    return json;\n  }\n\n  // Threejs GLTF Loader https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js#L1085\n  static resolveURI(uri, dir) {\n    // Invalid URI\n    if (typeof uri !== 'string' || uri === '') return '';\n\n    // Host Relative URI\n    if (/^https?:\\/\\//i.test(dir) && /^\\//.test(uri)) {\n      dir = dir.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    }\n\n    // Absolute URI http://, https://, //\n    if (/^(https?:)?\\/\\//i.test(uri)) return uri;\n\n    // Data URI\n    if (/^data:.*,.*$/i.test(uri)) return uri;\n\n    // Blob URI\n    if (/^blob:.*$/i.test(uri)) return uri;\n\n    // Relative URI\n    return dir + uri;\n  }\n  static async loadBuffers(desc, dir) {\n    if (!desc.buffers) return null;\n    return await Promise.all(desc.buffers.map(buffer => {\n      // For GLB, binary buffer ready to go\n      if (buffer.binary) return buffer.binary;\n      const uri = this.resolveURI(buffer.uri, dir);\n      return fetch(uri).then(res => res.arrayBuffer());\n    }));\n  }\n  static parseBufferViews(gl, desc, buffers) {\n    if (!desc.bufferViews) return null;\n    // Clone to leave description pure\n    const bufferViews = desc.bufferViews.map(o => Object.assign({}, o));\n    desc.meshes && desc.meshes.forEach(_ref => {\n      let {\n        primitives\n      } = _ref;\n      primitives.forEach(_ref2 => {\n        let {\n          attributes,\n          indices\n        } = _ref2;\n        // Flag bufferView as an attribute, so it knows to create a gl buffer\n        for (let attr in attributes) bufferViews[desc.accessors[attributes[attr]].bufferView].isAttribute = true;\n        if (indices === undefined) return;\n        bufferViews[desc.accessors[indices].bufferView].isAttribute = true;\n\n        // Make sure indices bufferView have a target property for gl buffer binding\n        bufferViews[desc.accessors[indices].bufferView].target = gl.ELEMENT_ARRAY_BUFFER;\n      });\n    });\n\n    // Get componentType of each bufferView from the accessors\n    desc.accessors.forEach(_ref3 => {\n      let {\n        bufferView: i,\n        componentType\n      } = _ref3;\n      bufferViews[i].componentType = componentType;\n    });\n\n    // Get mimetype of bufferView from images\n    desc.images && desc.images.forEach(_ref4 => {\n      let {\n        uri,\n        bufferView: i,\n        mimeType\n      } = _ref4;\n      if (i === undefined) return;\n      bufferViews[i].mimeType = mimeType;\n    });\n\n    // Push each bufferView to the GPU as a separate buffer\n    bufferViews.forEach((_ref5, i) => {\n      let {\n        buffer: bufferIndex,\n        // required\n        byteOffset = 0,\n        // optional\n        byteLength,\n        // required\n        byteStride,\n        // optional\n        target = gl.ARRAY_BUFFER,\n        // optional, added above for elements\n        name,\n        // optional\n        extensions,\n        // optional\n        extras,\n        // optional\n\n        componentType,\n        // optional, added from accessor above\n        mimeType,\n        // optional, added from images above\n        isAttribute\n      } = _ref5;\n      // For basis, just slice buffer\n      if (mimeType === 'image/ktx2') {\n        bufferViews[i].data = buffers[bufferIndex].slice(byteOffset, byteOffset + byteLength);\n        return;\n      }\n      const TypeArray = TYPE_ARRAY[componentType || mimeType];\n      const elementBytes = TypeArray.BYTES_PER_ELEMENT;\n      const data = new TypeArray(buffers[bufferIndex], byteOffset, byteLength / elementBytes);\n      bufferViews[i].data = data;\n      bufferViews[i].originalBuffer = buffers[bufferIndex];\n      if (!isAttribute) return;\n      // Create gl buffers for the bufferView, pushing it to the GPU\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(target, buffer);\n      gl.renderer.state.boundBuffer = buffer;\n      gl.bufferData(target, data, gl.STATIC_DRAW);\n      bufferViews[i].buffer = buffer;\n    });\n    return bufferViews;\n  }\n  static async parseImages(gl, desc, dir, bufferViews) {\n    if (!desc.images) return null;\n    return await Promise.all(desc.images.map(async _ref6 => {\n      let {\n        uri,\n        bufferView: bufferViewIndex,\n        mimeType,\n        name\n      } = _ref6;\n      if (mimeType === 'image/ktx2') {\n        const {\n          data\n        } = bufferViews[bufferViewIndex];\n        const image = await this.basisManager.parseTexture(data);\n        return image;\n      }\n\n      // jpg / png\n      const image = new Image();\n      image.name = name;\n      if (uri) {\n        image.src = this.resolveURI(uri, dir);\n      } else if (bufferViewIndex !== undefined) {\n        const {\n          data\n        } = bufferViews[bufferViewIndex];\n        const blob = new Blob([data], {\n          type: mimeType\n        });\n        image.src = URL.createObjectURL(blob);\n      }\n      image.ready = new Promise(res => {\n        image.onload = () => res();\n      });\n      return image;\n    }));\n  }\n  static parseTextures(gl, desc, images) {\n    if (!desc.textures) return null;\n    return desc.textures.map(_ref7 => {\n      let {\n        sampler: samplerIndex,\n        source: sourceIndex,\n        name,\n        extensions,\n        extras\n      } = _ref7;\n      if (sourceIndex === undefined && !!extensions) {\n        // Basis extension source index\n        if (extensions.KHR_texture_basisu) sourceIndex = extensions.KHR_texture_basisu.source;\n      }\n      const options = {\n        flipY: false,\n        wrapS: gl.REPEAT,\n        // Repeat by default, opposed to OGL's clamp by default\n        wrapT: gl.REPEAT\n      };\n      const sampler = samplerIndex !== undefined ? desc.samplers[samplerIndex] : null;\n      if (sampler) {\n        ['magFilter', 'minFilter', 'wrapS', 'wrapT'].forEach(prop => {\n          if (sampler[prop]) options[prop] = sampler[prop];\n        });\n      }\n      const image = images[sourceIndex];\n\n      // For compressed textures\n      if (image.isBasis) {\n        options.image = image;\n        options.internalFormat = image.internalFormat;\n        if (image.isCompressedTexture) {\n          options.generateMipmaps = false;\n          if (image.length > 1) this.minFilter = gl.NEAREST_MIPMAP_LINEAR;\n        }\n        const texture = new Texture(gl, options);\n        texture.name = name;\n        return texture;\n      }\n      const texture = new Texture(gl, options);\n      texture.name = name;\n      image.ready.then(() => {\n        texture.image = image;\n      });\n      return texture;\n    });\n  }\n  static parseMaterials(gl, desc, textures) {\n    if (!desc.materials) return null;\n    return desc.materials.map(_ref8 => {\n      let {\n        name,\n        extensions,\n        extras,\n        pbrMetallicRoughness = {},\n        normalTexture,\n        occlusionTexture,\n        emissiveTexture,\n        emissiveFactor = [0, 0, 0],\n        alphaMode = 'OPAQUE',\n        alphaCutoff = 0.5,\n        doubleSided = false\n      } = _ref8;\n      const {\n        baseColorFactor = [1, 1, 1, 1],\n        baseColorTexture,\n        metallicFactor = 1,\n        roughnessFactor = 1,\n        metallicRoughnessTexture\n        //   extensions,\n        //   extras,\n      } = pbrMetallicRoughness;\n      if (baseColorTexture) {\n        baseColorTexture.texture = textures[baseColorTexture.index];\n        // texCoord\n      }\n      if (normalTexture) {\n        normalTexture.texture = textures[normalTexture.index];\n        // scale: 1\n        // texCoord\n      }\n      if (metallicRoughnessTexture) {\n        metallicRoughnessTexture.texture = textures[metallicRoughnessTexture.index];\n        // texCoord\n      }\n      if (occlusionTexture) {\n        occlusionTexture.texture = textures[occlusionTexture.index];\n        // strength 1\n        // texCoord\n      }\n      if (emissiveTexture) {\n        emissiveTexture.texture = textures[emissiveTexture.index];\n        // texCoord\n      }\n      return {\n        name,\n        baseColorFactor,\n        baseColorTexture,\n        metallicFactor,\n        roughnessFactor,\n        metallicRoughnessTexture,\n        normalTexture,\n        occlusionTexture,\n        emissiveTexture,\n        emissiveFactor,\n        alphaMode,\n        alphaCutoff,\n        doubleSided\n      };\n    });\n  }\n  static parseSkins(gl, desc, bufferViews) {\n    if (!desc.skins) return null;\n    return desc.skins.map(_ref9 => {\n      let {\n        inverseBindMatrices,\n        // optional\n        skeleton,\n        // optional\n        joints // required\n        // name,\n        // extensions,\n        // extras,\n      } = _ref9;\n      return {\n        inverseBindMatrices: this.parseAccessor(inverseBindMatrices, desc, bufferViews),\n        skeleton,\n        joints\n      };\n    });\n  }\n  static parseMeshes(gl, desc, bufferViews, materials, skins) {\n    if (!desc.meshes) return null;\n    return desc.meshes.map((_ref0, meshIndex) => {\n      let {\n        primitives,\n        // required\n        weights,\n        // optional\n        name,\n        // optional\n        extensions,\n        // optional\n        extras // optional\n      } = _ref0;\n      // TODO: weights stuff ?\n      // Parse through nodes to see how many instances there are\n      // and if there is a skin attached\n      let numInstances = 0;\n      let skinIndex = false;\n      desc.nodes && desc.nodes.forEach(_ref1 => {\n        let {\n          mesh,\n          skin\n        } = _ref1;\n        if (mesh === meshIndex) {\n          numInstances++;\n          if (skin !== undefined) skinIndex = skin;\n        }\n      });\n      primitives = this.parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances).map(_ref10 => {\n        let {\n          geometry,\n          program,\n          mode\n        } = _ref10;\n        // Create either skinned mesh or regular mesh\n        const mesh = typeof skinIndex === 'number' ? new GLTFSkin(gl, {\n          skeleton: skins[skinIndex],\n          geometry,\n          program,\n          mode\n        }) : new Mesh(gl, {\n          geometry,\n          program,\n          mode\n        });\n        mesh.name = name;\n        if (mesh.geometry.isInstanced) {\n          // Tag mesh so that nodes can add their transforms to the instance attribute\n          mesh.numInstances = numInstances;\n          // Avoid incorrect culling for instances\n          mesh.frustumCulled = false;\n        }\n        return mesh;\n      });\n      return {\n        primitives,\n        weights,\n        name\n      };\n    });\n  }\n  static parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances) {\n    return primitives.map(_ref11 => {\n      let {\n        attributes,\n        // required\n        indices,\n        // optional\n        material: materialIndex,\n        // optional\n        mode = 4,\n        // optional\n        targets,\n        // optional\n        extensions,\n        // optional\n        extras // optional\n      } = _ref11;\n      const geometry = new Geometry(gl);\n\n      // Add each attribute found in primitive\n      for (let attr in attributes) {\n        geometry.addAttribute(ATTRIBUTES[attr], this.parseAccessor(attributes[attr], desc, bufferViews));\n      }\n\n      // Add index attribute if found\n      if (indices !== undefined) {\n        geometry.addAttribute('index', this.parseAccessor(indices, desc, bufferViews));\n      }\n\n      // Add instanced transform attribute if multiple instances\n      if (numInstances > 1) {\n        geometry.addAttribute('instanceMatrix', {\n          instanced: 1,\n          size: 16,\n          data: new Float32Array(numInstances * 16)\n        });\n      }\n\n      // TODO: materials\n      const program = new NormalProgram(gl);\n      if (materialIndex !== undefined) {\n        program.gltfMaterial = materials[materialIndex];\n      }\n      return {\n        geometry,\n        program,\n        mode\n      };\n    });\n  }\n  static parseAccessor(index, desc, bufferViews) {\n    // TODO: init missing bufferView with 0s\n    // TODO: support sparse\n\n    const {\n      bufferView: bufferViewIndex,\n      // optional\n      byteOffset = 0,\n      // optional\n      componentType,\n      // required\n      normalized = false,\n      // optional\n      count,\n      // required\n      type,\n      // required\n      min,\n      // optional\n      max,\n      // optional\n      sparse // optional\n      // name, // optional\n      // extensions, // optional\n      // extras, // optional\n    } = desc.accessors[index];\n    const {\n      data,\n      // attached in parseBufferViews\n      originalBuffer,\n      // attached in parseBufferViews\n      buffer,\n      // replaced to be the actual GL buffer\n      byteOffset: bufferByteOffset = 0,\n      // byteLength, // applied in parseBufferViews\n      byteStride = 0,\n      target\n      // name,\n      // extensions,\n      // extras,\n    } = bufferViews[bufferViewIndex];\n    const size = TYPE_SIZE[type];\n\n    // Parse data from joined buffers\n    const TypeArray = TYPE_ARRAY[componentType];\n    const elementBytes = data.BYTES_PER_ELEMENT;\n    const componentOffset = byteOffset / elementBytes;\n    const componentStride = byteStride / elementBytes;\n    const isInterleaved = !!byteStride && componentStride !== size;\n\n    // TODO: interleaved\n    const newData = isInterleaved ? data : new TypeArray(originalBuffer, byteOffset + bufferByteOffset, count * size);\n\n    // Return attribute data\n    return {\n      data: newData,\n      size,\n      type: componentType,\n      normalized,\n      buffer,\n      stride: byteStride,\n      offset: byteOffset,\n      count,\n      min,\n      max\n    };\n  }\n  static parseNodes(gl, desc, meshes, skins) {\n    if (!desc.nodes) return null;\n    const nodes = desc.nodes.map(_ref12 => {\n      let {\n        camera,\n        // optional\n        children,\n        // optional\n        skin: skinIndex,\n        // optional\n        matrix,\n        // optional\n        mesh: meshIndex,\n        // optional\n        rotation,\n        // optional\n        scale,\n        // optional\n        translation,\n        // optional\n        weights,\n        // optional\n        name,\n        // optional\n        extensions,\n        // optional\n        extras // optional\n      } = _ref12;\n      const node = new Transform();\n      if (name) node.name = name;\n\n      // Apply transformations\n      if (matrix) {\n        node.matrix.copy(matrix);\n        node.decompose();\n      } else {\n        if (rotation) node.quaternion.copy(rotation);\n        if (scale) node.scale.copy(scale);\n        if (translation) node.position.copy(translation);\n        node.updateMatrix();\n      }\n\n      // Flags for avoiding duplicate transforms and removing unused instance nodes\n      let isInstanced = false;\n      let isFirstInstance = true;\n\n      // add mesh if included\n      if (meshIndex !== undefined) {\n        meshes[meshIndex].primitives.forEach(mesh => {\n          if (mesh.geometry.isInstanced) {\n            isInstanced = true;\n            if (!mesh.instanceCount) {\n              mesh.instanceCount = 0;\n            } else {\n              isFirstInstance = false;\n            }\n            node.matrix.toArray(mesh.geometry.attributes.instanceMatrix.data, mesh.instanceCount * 16);\n            mesh.instanceCount++;\n            if (mesh.instanceCount === mesh.numInstances) {\n              // Remove properties once all instances added\n              delete mesh.numInstances;\n              delete mesh.instanceCount;\n              // Flag attribute as dirty\n              mesh.geometry.attributes.instanceMatrix.needsUpdate = true;\n            }\n          }\n\n          // For instances, only the first node will actually have the mesh\n          if (isInstanced) {\n            if (isFirstInstance) mesh.setParent(node);\n          } else {\n            mesh.setParent(node);\n          }\n        });\n      }\n\n      // Reset node if instanced to not duplicate transforms\n      if (isInstanced) {\n        // Remove unused nodes just providing an instance transform\n        if (!isFirstInstance) return null;\n        // Avoid duplicate transform for node containing the instanced mesh\n        node.matrix.identity();\n        node.decompose();\n      }\n      return node;\n    });\n    desc.nodes.forEach((_ref13, i) => {\n      let {\n        children = []\n      } = _ref13;\n      // Set hierarchy now all nodes created\n      children.forEach(childIndex => {\n        if (!nodes[childIndex]) return;\n        nodes[childIndex].setParent(nodes[i]);\n      });\n    });\n    return nodes;\n  }\n  static populateSkins(skins, nodes) {\n    if (!skins) return;\n    skins.forEach(skin => {\n      skin.joints = skin.joints.map((i, index) => {\n        const joint = nodes[i];\n        joint.bindInverse = new Mat4(...skin.inverseBindMatrices.data.slice(index * 16, (index + 1) * 16));\n        return joint;\n      });\n      if (skin.skeleton) skin.skeleton = nodes[skin.skeleton];\n    });\n  }\n  static parseAnimations(gl, desc, nodes, bufferViews) {\n    if (!desc.animations) return null;\n    return desc.animations.map(_ref14 => {\n      let {\n        channels,\n        // required\n        samplers,\n        // required\n        name // optional\n        // extensions, // optional\n        // extras,  // optional\n      } = _ref14;\n      const data = channels.map(_ref15 => {\n        let {\n          sampler: samplerIndex,\n          // required\n          target // required\n          // extensions, // optional\n          // extras, // optional\n        } = _ref15;\n        const {\n          input: inputIndex,\n          // required\n          interpolation = 'LINEAR',\n          output: outputIndex // required\n          // extensions, // optional\n          // extras, // optional\n        } = samplers[samplerIndex];\n        const {\n          node: nodeIndex,\n          // optional - TODO: when is it not included?\n          path // required\n          // extensions, // optional\n          // extras, // optional\n        } = target;\n        const node = nodes[nodeIndex];\n        const transform = TRANSFORMS[path];\n        const times = this.parseAccessor(inputIndex, desc, bufferViews).data;\n        const values = this.parseAccessor(outputIndex, desc, bufferViews).data;\n        return {\n          node,\n          transform,\n          interpolation,\n          times,\n          values\n        };\n      });\n      return {\n        name,\n        animation: new GLTFAnimation(data)\n      };\n    });\n  }\n  static parseScenes(desc, nodes) {\n    if (!desc.scenes) return null;\n    return desc.scenes.map(_ref16 => {\n      let {\n        nodes: nodesIndices = [],\n        name,\n        // optional\n        extensions,\n        extras\n      } = _ref16;\n      return nodesIndices.reduce((map, i) => {\n        // Don't add null nodes (instanced transforms)\n        if (nodes[i]) map.push(nodes[i]);\n        return map;\n      }, []);\n    });\n  }\n}","map":{"version":3,"names":["Geometry","Transform","Texture","Mesh","GLTFAnimation","GLTFSkin","Mat4","NormalProgram","TYPE_ARRAY","Uint8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","TYPE_SIZE","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","TRANSFORMS","translation","rotation","scale","GLTFLoader","setBasisManager","manager","basisManager","load","gl","src","dir","split","slice","join","desc","parseDesc","parse","_desc$extensionsRequi","asset","undefined","version","console","warn","extensionsRequired","includes","buffers","loadBuffers","renderer","bindVertexArray","bufferViews","parseBufferViews","images","parseImages","textures","parseTextures","materials","parseMaterials","skins","parseSkins","meshes","parseMeshes","nodes","parseNodes","populateSkins","animations","parseAnimations","scenes","parseScenes","scene","i","length","splice","json","match","fetch","then","res","arrayBuffer","glb","unpackGLB","header","Error","concat","jsonChunkHeader","jsonByteOffset","jsonByteLength","jsonText","TextDecoder","decode","JSON","byteLength","binaryChunkHeader","binaryByteOffset","binaryByteLength","binary","resolveURI","uri","test","replace","Promise","all","map","buffer","o","Object","assign","forEach","_ref","primitives","_ref2","attributes","indices","attr","accessors","bufferView","isAttribute","target","ELEMENT_ARRAY_BUFFER","_ref3","componentType","_ref4","mimeType","_ref5","bufferIndex","byteOffset","byteStride","ARRAY_BUFFER","name","extensions","extras","data","TypeArray","elementBytes","BYTES_PER_ELEMENT","originalBuffer","createBuffer","bindBuffer","state","boundBuffer","bufferData","STATIC_DRAW","_ref6","bufferViewIndex","image","parseTexture","Image","blob","Blob","type","URL","createObjectURL","ready","onload","_ref7","sampler","samplerIndex","source","sourceIndex","KHR_texture_basisu","options","flipY","wrapS","REPEAT","wrapT","samplers","prop","isBasis","internalFormat","isCompressedTexture","generateMipmaps","minFilter","NEAREST_MIPMAP_LINEAR","texture","_ref8","pbrMetallicRoughness","normalTexture","occlusionTexture","emissiveTexture","emissiveFactor","alphaMode","alphaCutoff","doubleSided","baseColorFactor","baseColorTexture","metallicFactor","roughnessFactor","metallicRoughnessTexture","index","_ref9","inverseBindMatrices","skeleton","joints","parseAccessor","_ref0","meshIndex","weights","numInstances","skinIndex","_ref1","mesh","skin","parsePrimitives","_ref10","geometry","program","mode","isInstanced","frustumCulled","_ref11","material","materialIndex","targets","addAttribute","instanced","size","gltfMaterial","normalized","count","min","max","sparse","bufferByteOffset","componentOffset","componentStride","isInterleaved","newData","stride","offset","_ref12","camera","children","matrix","node","copy","decompose","quaternion","position","updateMatrix","isFirstInstance","instanceCount","toArray","instanceMatrix","needsUpdate","setParent","identity","_ref13","childIndex","joint","bindInverse","_ref14","channels","_ref15","input","inputIndex","interpolation","output","outputIndex","nodeIndex","path","transform","times","values","animation","_ref16","nodesIndices","reduce","push"],"sources":["/Users/krishnapandey/Desktop/Codevo/node_modules/ogl/src/extras/GLTFLoader.js"],"sourcesContent":["import { Geometry } from '../core/Geometry.js';\nimport { Transform } from '../core/Transform.js';\nimport { Texture } from '../core/Texture.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { GLTFAnimation } from './GLTFAnimation.js';\nimport { GLTFSkin } from './GLTFSkin.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { NormalProgram } from './NormalProgram.js';\n\n// Supports\n// [x] Geometry\n// [ ] Sparse support\n// [x] Nodes and Hierarchy\n// [x] Instancing\n// [ ] Morph Targets\n// [x] Skins\n// [ ] Materials\n// [x] Textures\n// [x] Animation\n// [ ] Cameras\n// [ ] Extensions\n// [x] GLB support\n// [x] Basis/ktx2 support\n\n// TODO: Sparse accessor packing? For morph targets basically\n// TODO: init accessor missing bufferView with 0s\n// TODO: morph target animations\n// TODO: what to do if multiple instances are in different groups? Only uses local matrices\n// TODO: what if instancing isn't wanted? Eg collision maps\n// TODO: ie11 fallback for TextDecoder?\n\nconst TYPE_ARRAY = {\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array,\n    'image/jpeg': Uint8Array,\n    'image/png': Uint8Array,\n};\n\nconst TYPE_SIZE = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16,\n};\n\nconst ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex',\n};\n\nconst TRANSFORMS = {\n    translation: 'position',\n    rotation: 'quaternion',\n    scale: 'scale',\n};\n\nexport class GLTFLoader {\n    static setBasisManager(manager) {\n        this.basisManager = manager;\n    }\n\n    static async load(gl, src) {\n        const dir = src.split('/').slice(0, -1).join('/') + '/';\n\n        // load main description json\n        const desc = await this.parseDesc(src);\n\n        return await this.parse(gl, desc, dir);\n    }\n\n    static async parse(gl, desc, dir) {\n        if (desc.asset === undefined || desc.asset.version[0] < 2) console.warn('Only GLTF >=2.0 supported. Attempting to parse.');\n\n        if (desc.extensionsRequired?.includes('KHR_texture_basisu') && !this.basisManager)\n            console.warn('KHR_texture_basisu extension required but no manager supplied. Use .setBasisManager()');\n\n        // Load buffers async\n        const buffers = await this.loadBuffers(desc, dir);\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        gl.renderer.bindVertexArray(null);\n\n        // Create gl buffers from bufferViews\n        const bufferViews = this.parseBufferViews(gl, desc, buffers);\n\n        // Create images from either bufferViews or separate image files\n        const images = await this.parseImages(gl, desc, dir, bufferViews);\n\n        const textures = this.parseTextures(gl, desc, images);\n\n        // Just pass through material data for now\n        const materials = this.parseMaterials(gl, desc, textures);\n\n        // Fetch the inverse bind matrices for skeleton joints\n        const skins = this.parseSkins(gl, desc, bufferViews);\n\n        // Create geometries for each mesh primitive\n        const meshes = this.parseMeshes(gl, desc, bufferViews, materials, skins);\n\n        // Create transforms, meshes and hierarchy\n        const nodes = this.parseNodes(gl, desc, meshes, skins);\n\n        // Place nodes in skeletons\n        this.populateSkins(skins, nodes);\n\n        // Create animation handlers\n        const animations = this.parseAnimations(gl, desc, nodes, bufferViews);\n\n        // Get top level nodes for each scene\n        const scenes = this.parseScenes(desc, nodes);\n        const scene = scenes[desc.scene];\n\n        // Remove null nodes (instanced transforms)\n        for (let i = nodes.length; i >= 0; i--) if (!nodes[i]) nodes.splice(i, 1);\n\n        return {\n            json: desc,\n            buffers,\n            bufferViews,\n            images,\n            textures,\n            materials,\n            meshes,\n            nodes,\n            animations,\n            scenes,\n            scene,\n        };\n    }\n\n    static async parseDesc(src) {\n        if (!src.match(/\\.glb/)) {\n            return await fetch(src).then((res) => res.json());\n        } else {\n            return await fetch(src)\n                .then((res) => res.arrayBuffer())\n                .then((glb) => this.unpackGLB(glb));\n        }\n    }\n\n    // From https://github.com/donmccurdy/glTF-Transform/blob/e4108cc/packages/core/src/io/io.ts#L32\n    static unpackGLB(glb) {\n        // Decode and verify GLB header.\n        const header = new Uint32Array(glb, 0, 3);\n        if (header[0] !== 0x46546c67) {\n            throw new Error('Invalid glTF asset.');\n        } else if (header[1] !== 2) {\n            throw new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n        }\n        // Decode and verify chunk headers.\n        const jsonChunkHeader = new Uint32Array(glb, 12, 2);\n        const jsonByteOffset = 20;\n        const jsonByteLength = jsonChunkHeader[0];\n        if (jsonChunkHeader[1] !== 0x4e4f534a) {\n            throw new Error('Unexpected GLB layout.');\n        }\n\n        // Decode JSON.\n        const jsonText = new TextDecoder().decode(glb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength));\n        const json = JSON.parse(jsonText);\n        // JSON only\n        if (jsonByteOffset + jsonByteLength === glb.byteLength) return json;\n\n        const binaryChunkHeader = new Uint32Array(glb, jsonByteOffset + jsonByteLength, 2);\n        if (binaryChunkHeader[1] !== 0x004e4942) {\n            throw new Error('Unexpected GLB layout.');\n        }\n        // Decode content.\n        const binaryByteOffset = jsonByteOffset + jsonByteLength + 8;\n        const binaryByteLength = binaryChunkHeader[0];\n        const binary = glb.slice(binaryByteOffset, binaryByteOffset + binaryByteLength);\n        // Attach binary to buffer\n        json.buffers[0].binary = binary;\n        return json;\n    }\n\n    // Threejs GLTF Loader https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js#L1085\n    static resolveURI(uri, dir) {\n        // Invalid URI\n        if (typeof uri !== 'string' || uri === '') return '';\n\n        // Host Relative URI\n        if (/^https?:\\/\\//i.test(dir) && /^\\//.test(uri)) {\n            dir = dir.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n        }\n\n        // Absolute URI http://, https://, //\n        if (/^(https?:)?\\/\\//i.test(uri)) return uri;\n\n        // Data URI\n        if (/^data:.*,.*$/i.test(uri)) return uri;\n\n        // Blob URI\n        if (/^blob:.*$/i.test(uri)) return uri;\n\n        // Relative URI\n        return dir + uri;\n    }\n\n    static async loadBuffers(desc, dir) {\n        if (!desc.buffers) return null;\n        return await Promise.all(\n            desc.buffers.map((buffer) => {\n                // For GLB, binary buffer ready to go\n                if (buffer.binary) return buffer.binary;\n                const uri = this.resolveURI(buffer.uri, dir);\n                return fetch(uri).then((res) => res.arrayBuffer());\n            })\n        );\n    }\n\n    static parseBufferViews(gl, desc, buffers) {\n        if (!desc.bufferViews) return null;\n        // Clone to leave description pure\n        const bufferViews = desc.bufferViews.map((o) => Object.assign({}, o));\n\n        desc.meshes &&\n            desc.meshes.forEach(({ primitives }) => {\n                primitives.forEach(({ attributes, indices }) => {\n                    // Flag bufferView as an attribute, so it knows to create a gl buffer\n                    for (let attr in attributes) bufferViews[desc.accessors[attributes[attr]].bufferView].isAttribute = true;\n\n                    if (indices === undefined) return;\n                    bufferViews[desc.accessors[indices].bufferView].isAttribute = true;\n\n                    // Make sure indices bufferView have a target property for gl buffer binding\n                    bufferViews[desc.accessors[indices].bufferView].target = gl.ELEMENT_ARRAY_BUFFER;\n                });\n            });\n\n        // Get componentType of each bufferView from the accessors\n        desc.accessors.forEach(({ bufferView: i, componentType }) => {\n            bufferViews[i].componentType = componentType;\n        });\n\n        // Get mimetype of bufferView from images\n        desc.images &&\n            desc.images.forEach(({ uri, bufferView: i, mimeType }) => {\n                if (i === undefined) return;\n                bufferViews[i].mimeType = mimeType;\n            });\n\n        // Push each bufferView to the GPU as a separate buffer\n        bufferViews.forEach(\n            (\n                {\n                    buffer: bufferIndex, // required\n                    byteOffset = 0, // optional\n                    byteLength, // required\n                    byteStride, // optional\n                    target = gl.ARRAY_BUFFER, // optional, added above for elements\n                    name, // optional\n                    extensions, // optional\n                    extras, // optional\n\n                    componentType, // optional, added from accessor above\n                    mimeType, // optional, added from images above\n                    isAttribute,\n                },\n                i\n            ) => {\n                // For basis, just slice buffer\n                if (mimeType === 'image/ktx2') {\n                    bufferViews[i].data = buffers[bufferIndex].slice(byteOffset, byteOffset + byteLength);\n                    return;\n                }\n\n                const TypeArray = TYPE_ARRAY[componentType || mimeType];\n                const elementBytes = TypeArray.BYTES_PER_ELEMENT;\n\n                const data = new TypeArray(buffers[bufferIndex], byteOffset, byteLength / elementBytes);\n                bufferViews[i].data = data;\n                bufferViews[i].originalBuffer = buffers[bufferIndex];\n\n                if (!isAttribute) return;\n                // Create gl buffers for the bufferView, pushing it to the GPU\n                const buffer = gl.createBuffer();\n                gl.bindBuffer(target, buffer);\n                gl.renderer.state.boundBuffer = buffer;\n                gl.bufferData(target, data, gl.STATIC_DRAW);\n                bufferViews[i].buffer = buffer;\n            }\n        );\n\n        return bufferViews;\n    }\n\n    static async parseImages(gl, desc, dir, bufferViews) {\n        if (!desc.images) return null;\n        return await Promise.all(\n            desc.images.map(async ({ uri, bufferView: bufferViewIndex, mimeType, name }) => {\n                if (mimeType === 'image/ktx2') {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const image = await this.basisManager.parseTexture(data);\n                    return image;\n                }\n\n                // jpg / png\n                const image = new Image();\n                image.name = name;\n                if (uri) {\n                    image.src = this.resolveURI(uri, dir);\n                } else if (bufferViewIndex !== undefined) {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const blob = new Blob([data], { type: mimeType });\n                    image.src = URL.createObjectURL(blob);\n                }\n                image.ready = new Promise((res) => {\n                    image.onload = () => res();\n                });\n                return image;\n            })\n        );\n    }\n\n    static parseTextures(gl, desc, images) {\n        if (!desc.textures) return null;\n        return desc.textures.map(({ sampler: samplerIndex, source: sourceIndex, name, extensions, extras }) => {\n            if (sourceIndex === undefined && !!extensions) {\n                // Basis extension source index\n                if (extensions.KHR_texture_basisu) sourceIndex = extensions.KHR_texture_basisu.source;\n            }\n\n            const options = {\n                flipY: false,\n                wrapS: gl.REPEAT, // Repeat by default, opposed to OGL's clamp by default\n                wrapT: gl.REPEAT,\n            };\n            const sampler = samplerIndex !== undefined ? desc.samplers[samplerIndex] : null;\n            if (sampler) {\n                ['magFilter', 'minFilter', 'wrapS', 'wrapT'].forEach((prop) => {\n                    if (sampler[prop]) options[prop] = sampler[prop];\n                });\n            }\n\n            const image = images[sourceIndex];\n\n            // For compressed textures\n            if (image.isBasis) {\n                options.image = image;\n                options.internalFormat = image.internalFormat;\n                if (image.isCompressedTexture) {\n                    options.generateMipmaps = false;\n                    if (image.length > 1) this.minFilter = gl.NEAREST_MIPMAP_LINEAR;\n                }\n                const texture = new Texture(gl, options);\n                texture.name = name;\n                return texture;\n            }\n\n            const texture = new Texture(gl, options);\n            texture.name = name;\n            image.ready.then(() => {\n                texture.image = image;\n            });\n\n            return texture;\n        });\n    }\n\n    static parseMaterials(gl, desc, textures) {\n        if (!desc.materials) return null;\n        return desc.materials.map(\n            ({\n                name,\n                extensions,\n                extras,\n                pbrMetallicRoughness = {},\n                normalTexture,\n                occlusionTexture,\n                emissiveTexture,\n                emissiveFactor = [0, 0, 0],\n                alphaMode = 'OPAQUE',\n                alphaCutoff = 0.5,\n                doubleSided = false,\n            }) => {\n                const {\n                    baseColorFactor = [1, 1, 1, 1],\n                    baseColorTexture,\n                    metallicFactor = 1,\n                    roughnessFactor = 1,\n                    metallicRoughnessTexture,\n                    //   extensions,\n                    //   extras,\n                } = pbrMetallicRoughness;\n\n                if (baseColorTexture) {\n                    baseColorTexture.texture = textures[baseColorTexture.index];\n                    // texCoord\n                }\n                if (normalTexture) {\n                    normalTexture.texture = textures[normalTexture.index];\n                    // scale: 1\n                    // texCoord\n                }\n                if (metallicRoughnessTexture) {\n                    metallicRoughnessTexture.texture = textures[metallicRoughnessTexture.index];\n                    // texCoord\n                }\n                if (occlusionTexture) {\n                    occlusionTexture.texture = textures[occlusionTexture.index];\n                    // strength 1\n                    // texCoord\n                }\n                if (emissiveTexture) {\n                    emissiveTexture.texture = textures[emissiveTexture.index];\n                    // texCoord\n                }\n\n                return {\n                    name,\n                    baseColorFactor,\n                    baseColorTexture,\n                    metallicFactor,\n                    roughnessFactor,\n                    metallicRoughnessTexture,\n                    normalTexture,\n                    occlusionTexture,\n                    emissiveTexture,\n                    emissiveFactor,\n                    alphaMode,\n                    alphaCutoff,\n                    doubleSided,\n                };\n            }\n        );\n    }\n\n    static parseSkins(gl, desc, bufferViews) {\n        if (!desc.skins) return null;\n        return desc.skins.map(\n            ({\n                inverseBindMatrices, // optional\n                skeleton, // optional\n                joints, // required\n                // name,\n                // extensions,\n                // extras,\n            }) => {\n                return {\n                    inverseBindMatrices: this.parseAccessor(inverseBindMatrices, desc, bufferViews),\n                    skeleton,\n                    joints,\n                };\n            }\n        );\n    }\n\n    static parseMeshes(gl, desc, bufferViews, materials, skins) {\n        if (!desc.meshes) return null;\n        return desc.meshes.map(\n            (\n                {\n                    primitives, // required\n                    weights, // optional\n                    name, // optional\n                    extensions, // optional\n                    extras, // optional\n                },\n                meshIndex\n            ) => {\n                // TODO: weights stuff ?\n                // Parse through nodes to see how many instances there are\n                // and if there is a skin attached\n                let numInstances = 0;\n                let skinIndex = false;\n                desc.nodes &&\n                    desc.nodes.forEach(({ mesh, skin }) => {\n                        if (mesh === meshIndex) {\n                            numInstances++;\n                            if (skin !== undefined) skinIndex = skin;\n                        }\n                    });\n\n                primitives = this.parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances).map(({ geometry, program, mode }) => {\n                    // Create either skinned mesh or regular mesh\n                    const mesh =\n                        typeof skinIndex === 'number'\n                            ? new GLTFSkin(gl, { skeleton: skins[skinIndex], geometry, program, mode })\n                            : new Mesh(gl, { geometry, program, mode });\n                    mesh.name = name;\n                    if (mesh.geometry.isInstanced) {\n                        // Tag mesh so that nodes can add their transforms to the instance attribute\n                        mesh.numInstances = numInstances;\n                        // Avoid incorrect culling for instances\n                        mesh.frustumCulled = false;\n                    }\n                    return mesh;\n                });\n\n                return {\n                    primitives,\n                    weights,\n                    name,\n                };\n            }\n        );\n    }\n\n    static parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances) {\n        return primitives.map(\n            ({\n                attributes, // required\n                indices, // optional\n                material: materialIndex, // optional\n                mode = 4, // optional\n                targets, // optional\n                extensions, // optional\n                extras, // optional\n            }) => {\n                const geometry = new Geometry(gl);\n\n                // Add each attribute found in primitive\n                for (let attr in attributes) {\n                    geometry.addAttribute(ATTRIBUTES[attr], this.parseAccessor(attributes[attr], desc, bufferViews));\n                }\n\n                // Add index attribute if found\n                if (indices !== undefined) {\n                    geometry.addAttribute('index', this.parseAccessor(indices, desc, bufferViews));\n                }\n\n                // Add instanced transform attribute if multiple instances\n                if (numInstances > 1) {\n                    geometry.addAttribute('instanceMatrix', {\n                        instanced: 1,\n                        size: 16,\n                        data: new Float32Array(numInstances * 16),\n                    });\n                }\n\n                // TODO: materials\n                const program = new NormalProgram(gl);\n                if (materialIndex !== undefined) {\n                    program.gltfMaterial = materials[materialIndex];\n                }\n\n                return {\n                    geometry,\n                    program,\n                    mode,\n                };\n            }\n        );\n    }\n\n    static parseAccessor(index, desc, bufferViews) {\n        // TODO: init missing bufferView with 0s\n        // TODO: support sparse\n\n        const {\n            bufferView: bufferViewIndex, // optional\n            byteOffset = 0, // optional\n            componentType, // required\n            normalized = false, // optional\n            count, // required\n            type, // required\n            min, // optional\n            max, // optional\n            sparse, // optional\n            // name, // optional\n            // extensions, // optional\n            // extras, // optional\n        } = desc.accessors[index];\n\n        const {\n            data, // attached in parseBufferViews\n            originalBuffer, // attached in parseBufferViews\n            buffer, // replaced to be the actual GL buffer\n            byteOffset: bufferByteOffset = 0,\n            // byteLength, // applied in parseBufferViews\n            byteStride = 0,\n            target,\n            // name,\n            // extensions,\n            // extras,\n        } = bufferViews[bufferViewIndex];\n\n        const size = TYPE_SIZE[type];\n\n        // Parse data from joined buffers\n        const TypeArray = TYPE_ARRAY[componentType];\n        const elementBytes = data.BYTES_PER_ELEMENT;\n        const componentOffset = byteOffset / elementBytes;\n        const componentStride = byteStride / elementBytes;\n        const isInterleaved = !!byteStride && componentStride !== size;\n\n        // TODO: interleaved\n        const newData = isInterleaved ? data : new TypeArray(originalBuffer, byteOffset + bufferByteOffset, count * size);\n\n        // Return attribute data\n        return {\n            data: newData,\n            size,\n            type: componentType,\n            normalized,\n            buffer,\n            stride: byteStride,\n            offset: byteOffset,\n            count,\n            min,\n            max,\n        };\n    }\n\n    static parseNodes(gl, desc, meshes, skins) {\n        if (!desc.nodes) return null;\n        const nodes = desc.nodes.map(\n            ({\n                camera, // optional\n                children, // optional\n                skin: skinIndex, // optional\n                matrix, // optional\n                mesh: meshIndex, // optional\n                rotation, // optional\n                scale, // optional\n                translation, // optional\n                weights, // optional\n                name, // optional\n                extensions, // optional\n                extras, // optional\n            }) => {\n                const node = new Transform();\n                if (name) node.name = name;\n\n                // Apply transformations\n                if (matrix) {\n                    node.matrix.copy(matrix);\n                    node.decompose();\n                } else {\n                    if (rotation) node.quaternion.copy(rotation);\n                    if (scale) node.scale.copy(scale);\n                    if (translation) node.position.copy(translation);\n                    node.updateMatrix();\n                }\n\n                // Flags for avoiding duplicate transforms and removing unused instance nodes\n                let isInstanced = false;\n                let isFirstInstance = true;\n\n                // add mesh if included\n                if (meshIndex !== undefined) {\n                    meshes[meshIndex].primitives.forEach((mesh) => {\n                        if (mesh.geometry.isInstanced) {\n                            isInstanced = true;\n                            if (!mesh.instanceCount) {\n                                mesh.instanceCount = 0;\n                            } else {\n                                isFirstInstance = false;\n                            }\n                            node.matrix.toArray(mesh.geometry.attributes.instanceMatrix.data, mesh.instanceCount * 16);\n                            mesh.instanceCount++;\n\n                            if (mesh.instanceCount === mesh.numInstances) {\n                                // Remove properties once all instances added\n                                delete mesh.numInstances;\n                                delete mesh.instanceCount;\n                                // Flag attribute as dirty\n                                mesh.geometry.attributes.instanceMatrix.needsUpdate = true;\n                            }\n                        }\n\n                        // For instances, only the first node will actually have the mesh\n                        if (isInstanced) {\n                            if (isFirstInstance) mesh.setParent(node);\n                        } else {\n                            mesh.setParent(node);\n                        }\n                    });\n                }\n\n                // Reset node if instanced to not duplicate transforms\n                if (isInstanced) {\n                    // Remove unused nodes just providing an instance transform\n                    if (!isFirstInstance) return null;\n                    // Avoid duplicate transform for node containing the instanced mesh\n                    node.matrix.identity();\n                    node.decompose();\n                }\n\n                return node;\n            }\n        );\n\n        desc.nodes.forEach(({ children = [] }, i) => {\n            // Set hierarchy now all nodes created\n            children.forEach((childIndex) => {\n                if (!nodes[childIndex]) return;\n                nodes[childIndex].setParent(nodes[i]);\n            });\n        });\n\n        return nodes;\n    }\n\n    static populateSkins(skins, nodes) {\n        if (!skins) return;\n        skins.forEach((skin) => {\n            skin.joints = skin.joints.map((i, index) => {\n                const joint = nodes[i];\n                joint.bindInverse = new Mat4(...skin.inverseBindMatrices.data.slice(index * 16, (index + 1) * 16));\n                return joint;\n            });\n            if (skin.skeleton) skin.skeleton = nodes[skin.skeleton];\n        });\n    }\n\n    static parseAnimations(gl, desc, nodes, bufferViews) {\n        if (!desc.animations) return null;\n        return desc.animations.map(\n            ({\n                channels, // required\n                samplers, // required\n                name, // optional\n                // extensions, // optional\n                // extras,  // optional\n            }) => {\n                const data = channels.map(\n                    ({\n                        sampler: samplerIndex, // required\n                        target, // required\n                        // extensions, // optional\n                        // extras, // optional\n                    }) => {\n                        const {\n                            input: inputIndex, // required\n                            interpolation = 'LINEAR',\n                            output: outputIndex, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = samplers[samplerIndex];\n\n                        const {\n                            node: nodeIndex, // optional - TODO: when is it not included?\n                            path, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = target;\n\n                        const node = nodes[nodeIndex];\n                        const transform = TRANSFORMS[path];\n                        const times = this.parseAccessor(inputIndex, desc, bufferViews).data;\n                        const values = this.parseAccessor(outputIndex, desc, bufferViews).data;\n\n                        return {\n                            node,\n                            transform,\n                            interpolation,\n                            times,\n                            values,\n                        };\n                    }\n                );\n\n                return {\n                    name,\n                    animation: new GLTFAnimation(data),\n                };\n            }\n        );\n    }\n\n    static parseScenes(desc, nodes) {\n        if (!desc.scenes) return null;\n        return desc.scenes.map(\n            ({\n                nodes: nodesIndices = [],\n                name, // optional\n                extensions,\n                extras,\n            }) => {\n                return nodesIndices.reduce((map, i) => {\n                    // Don't add null nodes (instanced transforms)\n                    if (nodes[i]) map.push(nodes[i]);\n                    return map;\n                }, []);\n            }\n        );\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}