{"ast":null,"code":"// TODO: Destroy render targets if size changed and exists\n\nimport { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\nexport class Post {\n  constructor(gl, {\n    width,\n    height,\n    dpr,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    minFilter = gl.LINEAR,\n    magFilter = gl.LINEAR,\n    geometry = new Triangle(gl),\n    targetOnly = null\n  } = {}) {\n    this.gl = gl;\n    this.options = {\n      wrapS,\n      wrapT,\n      minFilter,\n      magFilter\n    };\n    this.passes = [];\n    this.geometry = geometry;\n    this.uniform = {\n      value: null\n    };\n    this.targetOnly = targetOnly;\n    const fbo = this.fbo = {\n      read: null,\n      write: null,\n      swap: () => {\n        let temp = fbo.read;\n        fbo.read = fbo.write;\n        fbo.write = temp;\n      }\n    };\n    this.resize({\n      width,\n      height,\n      dpr\n    });\n  }\n  addPass({\n    vertex = defaultVertex,\n    fragment = defaultFragment,\n    uniforms = {},\n    textureUniform = 'tMap',\n    enabled = true\n  } = {}) {\n    uniforms[textureUniform] = {\n      value: this.fbo.read.texture\n    };\n    const program = new Program(this.gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    const mesh = new Mesh(this.gl, {\n      geometry: this.geometry,\n      program\n    });\n    const pass = {\n      mesh,\n      program,\n      uniforms,\n      enabled,\n      textureUniform\n    };\n    this.passes.push(pass);\n    return pass;\n  }\n  resize({\n    width,\n    height,\n    dpr\n  } = {}) {\n    if (dpr) this.dpr = dpr;\n    if (width) {\n      this.width = width;\n      this.height = height || width;\n    }\n    dpr = this.dpr || this.gl.renderer.dpr;\n    width = Math.floor((this.width || this.gl.renderer.width) * dpr);\n    height = Math.floor((this.height || this.gl.renderer.height) * dpr);\n    this.options.width = width;\n    this.options.height = height;\n    this.fbo.read = new RenderTarget(this.gl, this.options);\n    this.fbo.write = new RenderTarget(this.gl, this.options);\n  }\n\n  // Uses same arguments as renderer.render, with addition of optional texture passed in to avoid scene render\n  render({\n    scene,\n    camera,\n    texture,\n    target = null,\n    update = true,\n    sort = true,\n    frustumCull = true\n  }) {\n    const enabledPasses = this.passes.filter(pass => pass.enabled);\n    if (!texture) {\n      this.gl.renderer.render({\n        scene,\n        camera,\n        target: enabledPasses.length || !target && this.targetOnly ? this.fbo.write : target,\n        update,\n        sort,\n        frustumCull\n      });\n      this.fbo.swap();\n    }\n    enabledPasses.forEach((pass, i) => {\n      pass.mesh.program.uniforms[pass.textureUniform].value = !i && texture ? texture : this.fbo.read.texture;\n      this.gl.renderer.render({\n        scene: pass.mesh,\n        target: i === enabledPasses.length - 1 && (target || !this.targetOnly) ? target : this.fbo.write,\n        clear: true\n      });\n      this.fbo.swap();\n    });\n    this.uniform.value = this.fbo.read.texture;\n  }\n}\nconst defaultVertex = /* glsl */`\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\nconst defaultFragment = /* glsl */`\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;","map":{"version":3,"names":["Program","Mesh","RenderTarget","Triangle","Post","constructor","gl","width","height","dpr","wrapS","CLAMP_TO_EDGE","wrapT","minFilter","LINEAR","magFilter","geometry","targetOnly","options","passes","uniform","value","fbo","read","write","swap","temp","resize","addPass","vertex","defaultVertex","fragment","defaultFragment","uniforms","textureUniform","enabled","texture","program","mesh","pass","push","renderer","Math","floor","render","scene","camera","target","update","sort","frustumCull","enabledPasses","filter","length","forEach","i","clear"],"sources":["/Users/krishnapandey/Desktop/Codevo/node_modules/ogl/src/extras/Post.js"],"sourcesContent":["// TODO: Destroy render targets if size changed and exists\n\nimport { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\n\nexport class Post {\n    constructor(\n        gl,\n        {\n            width,\n            height,\n            dpr,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            minFilter = gl.LINEAR,\n            magFilter = gl.LINEAR,\n            geometry = new Triangle(gl),\n            targetOnly = null,\n        } = {}\n    ) {\n        this.gl = gl;\n\n        this.options = { wrapS, wrapT, minFilter, magFilter };\n\n        this.passes = [];\n\n        this.geometry = geometry;\n\n        this.uniform = { value: null };\n        this.targetOnly = targetOnly;\n\n        const fbo = (this.fbo = {\n            read: null,\n            write: null,\n            swap: () => {\n                let temp = fbo.read;\n                fbo.read = fbo.write;\n                fbo.write = temp;\n            },\n        });\n\n        this.resize({ width, height, dpr });\n    }\n\n    addPass({ vertex = defaultVertex, fragment = defaultFragment, uniforms = {}, textureUniform = 'tMap', enabled = true } = {}) {\n        uniforms[textureUniform] = { value: this.fbo.read.texture };\n\n        const program = new Program(this.gl, { vertex, fragment, uniforms });\n        const mesh = new Mesh(this.gl, { geometry: this.geometry, program });\n\n        const pass = {\n            mesh,\n            program,\n            uniforms,\n            enabled,\n            textureUniform,\n        };\n\n        this.passes.push(pass);\n        return pass;\n    }\n\n    resize({ width, height, dpr } = {}) {\n        if (dpr) this.dpr = dpr;\n        if (width) {\n            this.width = width;\n            this.height = height || width;\n        }\n\n        dpr = this.dpr || this.gl.renderer.dpr;\n        width = Math.floor((this.width || this.gl.renderer.width) * dpr);\n        height = Math.floor((this.height || this.gl.renderer.height) * dpr);\n\n        this.options.width = width;\n        this.options.height = height;\n\n        this.fbo.read = new RenderTarget(this.gl, this.options);\n        this.fbo.write = new RenderTarget(this.gl, this.options);\n    }\n\n    // Uses same arguments as renderer.render, with addition of optional texture passed in to avoid scene render\n    render({ scene, camera, texture, target = null, update = true, sort = true, frustumCull = true }) {\n        const enabledPasses = this.passes.filter((pass) => pass.enabled);\n\n        if (!texture) {\n            this.gl.renderer.render({\n                scene,\n                camera,\n                target: enabledPasses.length || (!target && this.targetOnly) ? this.fbo.write : target,\n                update,\n                sort,\n                frustumCull,\n            });\n            this.fbo.swap();\n        }\n\n        enabledPasses.forEach((pass, i) => {\n            pass.mesh.program.uniforms[pass.textureUniform].value = !i && texture ? texture : this.fbo.read.texture;\n            this.gl.renderer.render({\n                scene: pass.mesh,\n                target: i === enabledPasses.length - 1 && (target || !this.targetOnly) ? target : this.fbo.write,\n                clear: true,\n            });\n            this.fbo.swap();\n        });\n\n        this.uniform.value = this.fbo.read.texture;\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}