{"ast":null,"code":"import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\nconst tmpVec3A = new Vec3();\nconst tmpVec3B = new Vec3();\nconst tmpVec3C = new Vec3();\nconst tmpVec3D = new Vec3();\nconst tmpQuatA = new Quat();\nconst tmpQuatB = new Quat();\nconst tmpQuatC = new Quat();\nconst tmpQuatD = new Quat();\nexport class GLTFAnimation {\n  constructor(data, weight = 1) {\n    this.data = data;\n    this.elapsed = 0;\n    this.weight = weight;\n\n    // Set to false to not apply modulo to elapsed against duration\n    this.loop = true;\n\n    // Find starting time as exports from blender (perhaps others too) don't always start from 0\n    this.startTime = data.reduce((a, {\n      times\n    }) => Math.min(a, times[0]), Infinity);\n    // Get largest final time in all channels to calculate duration\n    this.endTime = data.reduce((a, {\n      times\n    }) => Math.max(a, times[times.length - 1]), 0);\n    this.duration = this.endTime - this.startTime;\n  }\n  update(totalWeight = 1, isSet) {\n    const weight = isSet ? 1 : this.weight / totalWeight;\n    const elapsed = (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n    this.data.forEach(({\n      node,\n      transform,\n      interpolation,\n      times,\n      values\n    }) => {\n      // Get index of two time values elapsed is between\n      const prevIndex = Math.max(1, times.findIndex(t => t > elapsed)) - 1;\n      const nextIndex = prevIndex + 1;\n\n      // Get linear blend/alpha between the two\n      let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n      if (interpolation === 'STEP') alpha = 0;\n      let prevVal = tmpVec3A;\n      let prevTan = tmpVec3B;\n      let nextTan = tmpVec3C;\n      let nextVal = tmpVec3D;\n      let size = 3;\n      if (transform === 'quaternion') {\n        prevVal = tmpQuatA;\n        prevTan = tmpQuatB;\n        nextTan = tmpQuatC;\n        nextVal = tmpQuatD;\n        size = 4;\n      }\n      if (interpolation === 'CUBICSPLINE') {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n        prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n        nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n        nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n        // interpolate for final value\n        prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n        if (size === 4) prevVal.normalize();\n      } else {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size);\n        nextVal.fromArray(values, nextIndex * size);\n\n        // interpolate for final value\n        if (size === 4) prevVal.slerp(nextVal, alpha);else prevVal.lerp(nextVal, alpha);\n      }\n\n      // interpolate between multiple possible animations\n      if (size === 4) node[transform].slerp(prevVal, weight);else node[transform].lerp(prevVal, weight);\n    });\n  }\n  cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n    const s2 = 3 * t2 - 2 * t3;\n    const s3 = t3 - t2;\n    const s0 = 1 - s2;\n    const s1 = s3 - t2 + t;\n    for (let i = 0; i < prevVal.length; i++) {\n      prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n    }\n    return prevVal;\n  }\n}","map":{"version":3,"names":["Vec3","Quat","tmpVec3A","tmpVec3B","tmpVec3C","tmpVec3D","tmpQuatA","tmpQuatB","tmpQuatC","tmpQuatD","GLTFAnimation","constructor","data","weight","elapsed","loop","startTime","reduce","a","times","Math","min","Infinity","endTime","max","length","duration","update","totalWeight","isSet","forEach","node","transform","interpolation","values","prevIndex","findIndex","t","nextIndex","alpha","prevVal","prevTan","nextTan","nextVal","size","fromArray","cubicSplineInterpolate","normalize","slerp","lerp","t2","t3","s2","s3","s0","s1","i"],"sources":["/Users/krishnapandey/Desktop/Codevo/node_modules/ogl/src/extras/GLTFAnimation.js"],"sourcesContent":["import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst tmpVec3A = new Vec3();\nconst tmpVec3B = new Vec3();\nconst tmpVec3C = new Vec3();\nconst tmpVec3D = new Vec3();\n\nconst tmpQuatA = new Quat();\nconst tmpQuatB = new Quat();\nconst tmpQuatC = new Quat();\nconst tmpQuatD = new Quat();\n\nexport class GLTFAnimation {\n    constructor(data, weight = 1) {\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = weight;\n\n        // Set to false to not apply modulo to elapsed against duration\n        this.loop = true;\n\n        // Find starting time as exports from blender (perhaps others too) don't always start from 0\n        this.startTime = data.reduce((a, { times }) => Math.min(a, times[0]), Infinity);\n        // Get largest final time in all channels to calculate duration\n        this.endTime = data.reduce((a, { times }) => Math.max(a, times[times.length - 1]), 0);\n        this.duration = this.endTime - this.startTime;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n\n        this.data.forEach(({ node, transform, interpolation, times, values }) => {\n            // Get index of two time values elapsed is between\n            const prevIndex =\n                Math.max(\n                    1,\n                    times.findIndex((t) => t > elapsed)\n                ) - 1;\n            const nextIndex = prevIndex + 1;\n\n            // Get linear blend/alpha between the two\n            let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n            if (interpolation === 'STEP') alpha = 0;\n\n            let prevVal = tmpVec3A;\n            let prevTan = tmpVec3B;\n            let nextTan = tmpVec3C;\n            let nextVal = tmpVec3D;\n            let size = 3;\n\n            if (transform === 'quaternion') {\n                prevVal = tmpQuatA;\n                prevTan = tmpQuatB;\n                nextTan = tmpQuatC;\n                nextVal = tmpQuatD;\n                size = 4;\n            }\n\n            if (interpolation === 'CUBICSPLINE') {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n                prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n                nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n                nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n                // interpolate for final value\n                prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n                if (size === 4) prevVal.normalize();\n            } else {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size);\n                nextVal.fromArray(values, nextIndex * size);\n\n                // interpolate for final value\n                if (size === 4) prevVal.slerp(nextVal, alpha);\n                else prevVal.lerp(nextVal, alpha);\n            }\n\n            // interpolate between multiple possible animations\n            if (size === 4) node[transform].slerp(prevVal, weight);\n            else node[transform].lerp(prevVal, weight);\n        });\n    }\n\n    cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n\n        const s2 = 3 * t2 - 2 * t3;\n        const s3 = t3 - t2;\n        const s0 = 1 - s2;\n        const s1 = s3 - t2 + t;\n\n        for (let i = 0; i < prevVal.length; i++) {\n            prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n        }\n\n        return prevVal;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}